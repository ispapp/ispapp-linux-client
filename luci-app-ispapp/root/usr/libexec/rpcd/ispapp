#!/usr/bin/env lua
-- ispapp ubus api
local jsonc = require "luci.jsonc"
local nixio = require "nixio"
local fs = require "nixio.fs"
local UCI = require "luci.model.uci"
local util = require "luci.util"
local sys = require "luci.sys"
local http = require "luci.http"
local ubus = require "ubus"
local md5 = require "md5c"
-- local socket = require "socket"
local conn = ubus.connect()

local function log_to_syslog(level, message) nixio.syslog(level, message) end

local function log_error(message)
    log_to_syslog("err", "[luci.ispapp]: " .. message)
end

local function read_file(path)
    local file, err = fs.readfile(path)
    if not file then
        log_error("Failed to read file " .. path .. ": " .. err)
        return {error = "Failed to read file."}
    end
    return {result = file}
end

local function exec_command(cmd)
    local output = util.exec(cmd)
    if output == nil then
        log_error("Failed to execute command: " .. cmd)
        return {error = "Failed to execute command."}
    end
    return {result = output}
end

local function manage_service(action)
    local cmd = "/etc/init.d/ispapp " .. action
    return exec_command(cmd)
end

local function query_service()
    local cmd = "/etc/init.d/ispapp query *"
    return exec_command(cmd)
end

local function get_last_edit_time()
    local stat = fs.stat("/etc/config/ispapp")
    if stat and stat.mtime then return os.date("%Y-%m-%d %H:%M:%S", tonumber(stat.mtime)) end
    return "N/A"
end

local function get_active_time()
    local datetime = sys.exec("date +'%Y-%m-%d %H:%M:%S'"):gsub("\n", "") -- Execute the command
    return datetime or "N/A" -- Return the result or "N/A" if the command fails
end

local function set_config(data)
    local uci = UCI.cursor()

    -- Apply configuration changes to 'settings' section
    uci:set("ispapp", "settings", "enabled", data.enabled or '')
    uci:set("ispapp", "settings", "login", data.login or '')
    uci:set("ispapp", "settings", "topDomain", data.topDomain or '')
    uci:set("ispapp", "settings", "topListenerPort", data.topListenerPort or '')
    uci:set("ispapp", "settings", "topSmtpPort", data.topSmtpPort or '')
    uci:set("ispapp", "settings", "topKey", data.topKey or '')
    uci:set("ispapp", "settings", "ipbandswtestserver",
            data.ipbandswtestserver or '')
    uci:set("ispapp", "settings", "btuser", data.btuser or '')
    uci:set("ispapp", "settings", "btpwd", data.btpwd or '')

    local success, err = uci:commit("ispapp")
    if not success then
        log_error("Failed to commit changes to /etc/config/ispapp: " .. err)
        return {error = "Failed to save configuration."}
    end

    return {result = "Configuration saved successfully."}
end
-- verify config and make sure it's exist and filled with defaults if necessary
local function verify_config()
    local config = "ispapp"
    local section = "settings"
    local uci = UCI.cursor()
    -- Check if the ispapp config file and section exists
    if not uci:get(config, section) then
        -- Create the 'config' section with default options if it doesn't exist
        set_config({
            enabled = '0',
            login = '00000000-0000-0000-0000-000000000000',
            topDomain = 'localhost',
            topListenerPort = '8550',
            topSmtpPort = '8465',
            topKey = '',
            accessToken = '',
            refreshToken = '',
            connected = '0',
            ipbandswtestserver = '3.239.254.95',
            btuser = 'btest',
            btpwd = '0XSYIGkRlP6MUQJMZMdrogi2'
        })
        -- Commit the changes after creating the config
        uci:commit(config)
    end
end
-- run verify_configs function to make sure all ok
verify_config()

local sys = require("luci.sys") -- Make sure to import sys

local function get_cpu_usage()
    -- Get the PID of the ispappd process
    local pid = sys.exec("pidof ispappd"):match("%d+")
    
    if not pid then
        return "ispappd is not running"
    end

    -- Read the CPU usage stats for the specific PID from /proc/[pid]/stat
    local stat_file = string.format("/proc/%s/stat", pid)
    local proc_stat = sys.exec(string.format("cat %s", stat_file))

    -- Extract the necessary values from the stat file
    local utime, stime = proc_stat:match("%S+ %S+ %S+ %S+ %S+ %S+ %S+ %S+ %S+ %S+ %S+ (%d+) (%d+)")

    -- Convert to numbers
    utime = tonumber(utime) or 0 -- User mode time
    stime = tonumber(stime) or 0 -- Kernel mode time

    -- Total time spent on the process in clock ticks
    local total_time = utime + stime

    -- Get the system's clock ticks per second
    local clock_ticks_per_second = tonumber(sys.exec("getconf CLK_TCK"))

    -- Calculate CPU time in seconds
    local cpu_time_seconds = total_time / clock_ticks_per_second

    -- Format the CPU usage for ispappd
    return string.format("ispappd CPU Usage: %.2f seconds", cpu_time_seconds)
end


local function get_device_mode()
    local mode_count = {}
    local uci = UCI.cursor()
    -- Iterate over all wireless interfaces
    uci:foreach("wireless", "wifi-iface", function(section)
        if section.mode then
            local mode = section.mode
            -- Count occurrences of each mode
            mode_count[mode] = (mode_count[mode] or 0) + 1
        end
    end)
    -- Determine the majority mode
    local majority_mode, max_count = nil, 0
    for mode, count in pairs(mode_count) do
        if count > max_count then
            majority_mode = mode
            max_count = count
        end
    end

    -- Return the majority mode or a default value if none found
    return majority_mode or "N/A"
end

local function get_config()
    local uci = UCI.cursor()
    local sections = uci:get_all("ispapp", "config")
    return sections
end



-- Function to check if a command exists
local function commandExists(command)
    return sys.exec("opkg list-installed | grep " .. command) ~= "" and true or
               false
end

-- Function to extract a value by key from the release info
local function getReleaseValue(key)
    -- Read the content of /etc/openwrt_release
    local release_info = sys.exec("cat /etc/openwrt_release")
    local pattern = key .. "='(.-)'"
    return release_info:match(pattern)
end

local function getCPUInfo()
    -- Execute the command to get the content of /proc/cpuinfo
    local cpuinfo = sys.exec("cat /proc/cpuinfo")

    local core_count = 0
    local model_name = ""

    -- Iterate through each line of /proc/cpuinfo
    for line in cpuinfo:gmatch("[^\r\n]+") do
        -- Check for processor lines to count the cores
        if line:find("^processor%s*:%s*%d+") then
            core_count = core_count + 1
        end

        -- Check for model name
        if line:find("^model name%s*:%s*") then
            model_name = line:match("^model name%s*:%s*(.+)")
        end
    end

    -- Return the number of cores and the model name
    return core_count, model_name
end

local function getHardwareSerialNumber()
    local serial = sys.exec("cat /proc/cpuinfo | grep Serial")
    return serial:match("Serial%s*:%s*(%S+)") or "Unknown"
end

-- Single function to fetch interfaces, check for bridge memberships, and gather network stats
local function getNetworkInterfaces()
    local interfaces = {}

    -- Ensure the ubus connection is established
    if not conn then return nil, "Failed to connect to ubus" end

    -- Function to get bridge members for a specific bridge (e.g., br-lan)
    local function getBridgeMembers(bridge)
        local bridgeStatus = conn:call("network.device", "status",
                                       {name = bridge})
        return bridgeStatus['bridge-members'] or {}
    end

    -- Fetch all network devices using 'network.device' from ubus
    local devices = conn:call("network.device", "status", {})

    -- Track which interfaces belong to which bridges
    local bridgeMembers = {}

    -- Check for any bridges and fetch their members
    for iface, data in pairs(devices) do
        if data.type == "bridge" then
            local members = getBridgeMembers(iface)
            for _, member in ipairs(members) do
                bridgeMembers[member] = iface -- Map bridge members to the bridge (master interface)
            end
        end
    end

    -- Iterate over each device (interface)
    for iface, data in pairs(devices) do
        local mac = data.macaddr or "00:00:00:00:00:00" -- Default to all zeros if MAC is missing

        -- If no MAC address is present, skip this interface
        if mac ~= nil then
            -- Check if the interface is part of a bridge and assign the bridge as the default interface
            local defaultIf = bridgeMembers[iface] or iface

            -- Extract network statistics from the 'statistics' table in the ubus data
            local stats = data.statistics or {}

            -- Add the interface with its stats to the table
            table.insert(interfaces, {
                defaultIf = defaultIf, -- Set to bridge if part of a bridge, otherwise use iface
                ["if"] = iface,
                mac = mac, -- Keep MAC address even if it is '00:00:00:00:00:00'
                recBytes = stats.rx_bytes or 0,
                sentBytes = stats.tx_bytes or 0,
                recPackets = stats.rx_packets or 0,
                sentPackets = stats.tx_packets or 0,
                recErrors = stats.rx_errors or 0,
                sentErrors = stats.tx_errors or 0,
                recDrops = stats.rx_dropped or 0,
                sentDrops = stats.tx_dropped or 0,
                carrierChanges = stats.tx_carrier_errors or 0, -- Use tx_carrier_errors for carrier change stats
                foundDescriptor = "ubus parsed"
            })
        end
    end

    -- Return the list of interfaces
    return interfaces
end

-- Function to get external IP info and fill missing fields with "N/A"
local function getExternalIpInfo()
    -- Perform an HTTP GET request using luci.sys.httpget and fetch the JSON response as a string
    local jsonString = sys.httpget("http://ifconfig.co/json", false)

    -- Initialize a table with "N/A" as default values
    local info = {
        ip = "N/A",
        country = "N/A",
        city = "N/A",
        asn = "N/A",
        region_name = "N/A",
        region_code = "N/A",
        time_zone = "N/A",
        latitude = "N/A",
        longitude = "N/A",
        country_iso = "N/A"
    }

    -- Try to parse the JSON data if jsonString is not nil or empty
    if jsonString and jsonString ~= "" then
        local parsedData = jsonc.parse(jsonString)

        -- Check if JSON parsing is successful and then extract data
        if parsedData then
            info.ip = parsedData.ip or "N/A"
            info.country = parsedData.country or "N/A"
            info.city = parsedData.city or "N/A"
            info.asn = parsedData.asn or "N/A"
            info.region_name =
                parsedData.region_name and parsedData.region_name or "N/A"
            info.region_code =
                parsedData.region_code and parsedData.region_code or "N/A"
            info.time_zone = parsedData.time_zone and parsedData.time_zone or
                                 "N/A"
            info.latitude = parsedData.latitude and parsedData.latitude or "N/A"
            info.longitude = parsedData.longitude and parsedData.longitude or
                                 "N/A"
            info.country_iso =
                parsedData.country_iso and parsedData.country_iso or "N/A"
        end
    end

    -- Return the info table, ignoring any errors
    return info
end

-- Function to parse /etc/os-release and return information as a Lua table
local function parseOsRelease()
    local osReleasePath = "/etc/os-release"
    local osInfo = {
        NAME = "N/A",
        VERSION = "N/A",
        ID = "N/A",
        ID_LIKE = "N/A",
        PRETTY_NAME = "N/A",
        VERSION_ID = "N/A",
        HOME_URL = "N/A",
        BUG_URL = "N/A",
        SUPPORT_URL = "N/A",
        BUILD_ID = "N/A",
        OPENWRT_BOARD = "N/A",
        OPENWRT_ARCH = "N/A",
        OPENWRT_TAINTS = "N/A",
        OPENWRT_DEVICE_MANUFACTURER = "N/A",
        OPENWRT_DEVICE_MANUFACTURER_URL = "N/A",
        OPENWRT_DEVICE_PRODUCT = "N/A",
        OPENWRT_DEVICE_REVISION = "N/A",
        OPENWRT_RELEASE = "N/A"
    }

    -- Check if the file exists
    if fs.access(osReleasePath) then
        -- Read the file contents
        local fileContent = fs.readfile(osReleasePath)
        if fileContent and fileContent ~= "" then
            -- Split content into lines
            for line in fileContent:gmatch("[^\r\n]+") do
                -- Split each line into key and value
                local key, value = line:match("^(%S+)=\"?(.*)\"?$")
                if key and value then
                    osInfo[key] = value:gsub('\"$', "") -- Store the value in the osInfo table
                end
            end
        end
    end

    return osInfo
end

-- Function to collect security profiles of all wireless interfaces from UCI
local function collectSecurityProfiles()
    local profiles = {}
    local uci = UCI.cursor()
    -- Create a table to map device section to MAC address, hwmode, and htmode
    local device_info = {}

    -- Get all wireless device and interface sections
    -- uci:foreach("wireless", "wifi-device", function(section)
    --     device_info[section[".name"]] = {macaddr = section.macaddr or "N/A"}
    -- end)
    -- Get the hostname for the supplicant-identity
    -- local hostname = sys.hostname()
    uci:foreach("wireless", "wifi-iface", function(section)
        local profile = {
            [".id"] = "*" .. tostring(section['.index']), -- Use index as ID for the profile
            ["name"] = tostring(section['.name']),
            ["authentication-types"] = {section.encryption or "none"}, -- Directly use section.encryption
            -- name = section.ssid or "N/A", -- Use SSID or default
            -- ["supplicant-identity"] = hostname, -- Set supplicant-identity to the hostname
            technology = "wireless"
        }
        if section.sae_password then
            profile["wpa3-pre-shared-key"] = section.sae_password or "N/A"
        end
        if section.key then
            profile["wpa-pre-shared-key"] = section.key
            profile["wpa2-pre-shared-key"] = section.key
        end
        -- Get device information from the corresponding wifi-device section
        local device_name = section.device or "default" -- Get the device name associated with the iface
        -- local device_details = device_info[device_name] or
        --                            {
        --         macaddr = "N/A",
        --         hwmode = "N/A",
        --         htmode = "N/A"
        --     }
        -- -- Add MAC address, hwmode, and htmode to the profile
        -- profile["mac-addr"] = device_details.macaddr
        profile["mode"] = section.mode
        profile["default"] = false
        -- if section.mld and section.mld ~= "" then
        --     profile["default"] =  true
        -- end
        -- Add the profile to the profiles table
        table.insert(profiles, profile)
    end)

    return profiles
end

local function get_sequence_time()
    local config = "ispapp"
    local section = "config"
    local uci = UCI.cursor()
    -- Get current sequenceNumber and increment it
    local sequenceNumber = tonumber(
                               uci:get(config, section, "sequenceNumber") or "0")
    sequenceNumber = sequenceNumber + 1

    -- Get the current timestamp for lastConfigRequest (as a Unix timestamp)
    local lastConfigRequest = tonumber(sys.exec("date +%s"))

    -- Update UCI with new values
    uci:set(config, section, "sequenceNumber", tostring(sequenceNumber))
    uci:set(config, section, "lastConfigRequest", lastConfigRequest)

    -- Commit the changes to UCI
    uci:commit(config)

    -- Return the updated values
    return {
        lastConfigRequest = tonumber(lastConfigRequest),
        sequenceNumber = sequenceNumber
    }
end

local function is_using_websocket()
    local config = "ispapp"
    local section = "config"
    local uci = UCI.cursor()
    -- Retrieve the topDomain value from the config
    local topDomain = uci:get(config, section, "topDomain")

    -- Check if topDomain starts with ws:// or wss:// (for WebSocket and secure WebSocket)
    if topDomain and (topDomain:match("^ws://") or topDomain:match("^wss://")) then
        return true
    else
        return false
    end
end

local function wirelessSupport()
    -- Try to find wireless interfaces using 'iw dev'
    local iw_output = sys.exec("iw dev")

    -- If 'iw dev' has output, then wireless interfaces exist
    if iw_output and iw_output ~= "" then return true end

    -- If 'iw dev' didn't return anything, try using 'ifconfig'
    local ifconfig_output = sys.exec("ifconfig -a")

    -- Look for typical wireless interface prefixes (e.g., wlan, wifi)
    local wireless_interfaces = {"wlan", "wifi", "ath", "ra"} -- Common wireless prefixes

    for _, prefix in ipairs(wireless_interfaces) do
        if ifconfig_output:match(prefix) then return true end
    end

    -- If no wireless interfaces found, return false
    return false
end

local function wirelessConfigured()
    local wireless_info = {}
    local band_map = {
        ["11-1997"] = "2.4ghz-dsss/fhss",
        ["11b"] = "2.4ghz-hr/dsss",
        ["11a"] = "5ghz-ofdm",
        ["11g"] = "2.4ghz-erp-ofdm",
        ["11n"] = "2.4/5ghz-ht-ofdm",
        ["11beg"] = "2.4ghz-ofdm",
        ["11ac"] = "5ghz-vht-ofdm",
        ["11ax"] = "2.4/5/6ghz-he-ofdma",
        ["11be"] = "2.4/5/6ghz-eht-ofdma",
        ["11ad"] = "60ghz-dmg",
        ["11ay"] = "60ghz-edmg",
        ["11ah"] = "sub-1ghz-s1g",
        ["11p"] = "5.9ghz-vehicular",
        ["11bd"] = "5.9/60ghz-vehicular",
        ["11ba"] = "2.4/5ghz-wur",
        ["11bn"] = "2.4/5/6/42/60/71ghz-uhr",
        ["11bea"] = "2.4/5/6ghz-eht-ofdma"
    }

    local uci = UCI.cursor()
    uci:foreach("wireless", "wifi-iface", function(section)
        local device = section.device
        local ssid = section.ssid or "N/A"
        local encryption = section.encryption or "none"
        local macaddr = uci:get("wireless", device, "macaddr") or "N/A"
        local disabled = section.disabled == "1"
        local running = sys.exec("iw dev " .. section.device ..
                                     " info 2>/dev/null"):match("Interface") ~=
                            nil
        local band = uci:get("wireless", device, "hwmode") or "N/A"
        local interface_type = uci:get("wireless", device, "type") or "N/A"

        -- Translate the band (hwmode) into readable format
        local band_readable = band_map[band] or "N/A"
        -- local band_readable = band_map[band] or "N/A"

        -- Build the object structure
        table.insert(wireless_info, {
            [".id"] = "*" .. tostring(section['.index']),
            band = band_readable,
            disabled = disabled,
            ["hide-ssid"] = section.hidden == "1",
            name = section['.name'] or "N/A",
            ["if"] = section['.name'] or "N/A",
            ["interface-type"] = interface_type,
            key = section.key or "N/A",
            ["mac-address"] = macaddr,
            ["master-interface"] = interface_type,
            running = running,
            ["security-profile"] = "*" .. tostring(section['.index']),
            ssid = ssid,
            technology = "uci"
        })
    end)

    return wireless_info
end
-- get uptime in seconds
local function get_uptime()
    local uptime_str = sys.exec("cat /proc/uptime")
    local uptime_seconds, idle_time_seconds = uptime_str:match("^(%S+) (%S+)")
    return math.floor(tonumber(uptime_seconds) or 0), math.floor(tonumber(idle_time_seconds) or 0)
end

-- Function to generate the CollectConfigs response
local function CollectConfigs()
    local seq_lasttmp = get_sequence_time()
    local cpucores, cpumodel = getCPUInfo()
    local ipinfo = getExternalIpInfo()
    local osrelease = parseOsRelease()
    local uptime, idle_time = get_uptime()
    local response = {
        bandwidthTestSupport = commandExists("iperf") or commandExists("iperf3") or
            commandExists("btest"),
        clientInfo = getReleaseValue("DISTRIB_ID") .. "-" ..
            getReleaseValue("DISTRIB_RELEASE"),
        firmwareUpgradeSupport = commandExists("fwupgrade-tools"),
        fw = getReleaseValue("DISTRIB_DESCRIPTION"),
        hardwareCpuInfo = cpumodel .. ", " .. cpucores .. " cores",
        hardwareMake = sys.exec("cat /tmp/sysinfo/board_name"):gsub("%s+$", ""),
        hardwareModel = sys.exec("cat /sys/firmware/devicetree/base/model"),
        hardwareModelNumber = sys.exec("cat /tmp/sysinfo/model"):gsub("%s+$", ""),
        hardwareSerialNumber = getHardwareSerialNumber(),
        hostname = sys.hostname(),
        interfaces = getNetworkInterfaces(),
        lastConfigRequest = seq_lasttmp.lastConfigRequest,
        os = osrelease.VERSION_ID,
        osBuildDate = fs.stat("/sys/class").mtime,
        osVersion = osrelease.VERSION,
        outsideIp = ipinfo.ip,
        Lng = tonumber(ipinfo.longitude),
        lat = tonumber(ipinfo.latitude),
        ["security-profiles"] = collectSecurityProfiles(),
        sequenceNumber = seq_lasttmp.sequenceNumber,
        uptime = uptime,
        usingWebSocket = is_using_websocket(),
        webshellSupport = true,
        wirelessConfigured = wirelessConfigured(),
        wirelessSupport = wirelessSupport()
    }

    return {result = jsonc.stringify(response)}
end

-- Function to generate a unique identifier based on system properties
local function gather_unique_id()
    -- Function to get the MAC address using `ifconfig`
    local function get_mac_address()
        local mac_address = nil
        -- Run the `ifconfig` command and capture the output
        local ifconfig_output = sys.exec("/sbin/ifconfig -a")
        if not ifconfig_output then return "00:00:00:00:00:00" end
        -- Look for the MAC address in the output (adjust the pattern if needed)
        mac_address = ifconfig_output:match(
                          "HWaddr (%x%x:%x%x:%x%x:%x%x:%x%x:%x%x)")

        -- If no MAC address found, fall back to nil
        return mac_address or "00:00:00:00:00:00"
    end
    -- Gather necessary values
    local mac_address = get_mac_address() -- MAC address of the specified interface
    local cpucores = tonumber(sys.exec(
                                  "cat /proc/cpuinfo | grep 'processor' | wc -l")) or
                         0 -- Number of CPU cores

    -- Get RAM size
    local ram_size = 0
    local ram_partitions = tonumber(sys.exec(
                                        "cat /proc/partitions | grep ram | wc -l")) or
                               0
    if ram_partitions > 0 then
        ram_size = ram_partitions * 4096 -- Assuming each ram partition is 4096 blocks
    end

    -- Get MTD size and count
    local mtd_size = 0
    local mtd_partitions = tonumber(sys.exec(
                                        "cat /proc/partitions | grep mtdblock | wc -l")) or
                               0
    if mtd_partitions > 0 then
        local mtd_data = sys.exec("cat /proc/partitions | grep mtdblock")
        for line in mtd_data:gmatch("[^\r\n]+") do
            local _, _, blocks = line:find("(%d+)%s+(%d+)%s+(%d+)%s+mtdblock%d")
            if blocks then mtd_size = mtd_size + tonumber(blocks) end
        end
    end

    -- Gather CPU specifications (e.g., BogoMIPS)
    local bogomips = sys.exec(
                         "cat /proc/cpuinfo | grep 'BogoMIPS' | head -n 1 | awk '{print $3}'") or
                         "0"

    -- Number of ports can be gathered from network interfaces
    local num_ports = tonumber(sys.exec(
                                   "ls /sys/class/net/ | grep 'eth' | wc -l")) or
                          0

    -- Combine all values into a string
    local unique_string = string.format("%s%d%d%d%s%d", mac_address, cpucores,
                                        ram_size, mtd_size, bogomips, num_ports)
    -- local md5_module, err = pcall(require, "md5c")
    -- Function to generate UUID format from the unique string
    local hash = md5.tohex(unique_string:gsub("[%.:\n]", "")) -- or use any hashing library available
    local res = string.format("%s-%s-4%s-%s-%s", hash:sub(1, 8),
                              hash:sub(9, 12), hash:sub(13, 16),
                              hash:sub(17, 20), hash:sub(21))

    return res
end

local function host_signup()
    local uci = UCI.cursor()
    if not uci.get("ispapp", "config") then return nil end
    local host = uci.get("ispapp", "settings", "topDomain") or
                     "provisioning.ispapp.co"
    local port = uci.get("ispapp", "settings", "topListenerPort") or "8550"
    local key = uci.get("ispapp", "settings", "topKey") or ""
    local req = string.format("curl -k https://%s:%s/auth/uuid", host, port)
    local login = ""
    local uci_login = uci.get("ispapp", "settings", "login")
    local env_login = sys.exec(
                          "fw_printenv | grep login | awk -F '=' '{print $2}'")
    local function set_login(_login)
        uci.set("ispapp", "settings", "login", login)
        uci.commit("ispapp")
    end
    if uci_login and uci_login ~= "00000000-0000-0000-0000-000000000000" then
        login = uci_login
    elseif env_login and env_login ~= "00000000-0000-0000-0000-000000000000" then
        login = env_login
        set_login(uci_login)
    else
        login = sys.exec(req) or gather_unique_id()
        set_login(login)
    end
    local function init_config(configs)
        local _req = string.format(
                         "curl -k -X POST \"https://%s:%s/initconfig\" -d \"login=%s&key=%s\" -H \"Content-Type: application/json\" -d '%s'",
                         host, port, login, key, configs)
        local ok, content = pcall(sys.exec, _req)
        if not ok then return "err" end
        return content, _req
    end
    local token, _req = init_config(CollectConfigs().result)
    return {token = token, _req = _req}
end

local function TestMe()
    local upt, idle = get_uptime()
    local responce = {["results"] = math.floor(upt)}
    return {result = jsonc.stringify(responce)}
end
local function SignUp()
    local sd = host_signup()
    if not sd then return {result = ""} end
    local responce = {["results"] = sd.token}
    return {result = jsonc.stringify(responce)}
end

local methods = {

    demo = {call = TestMe},
    test = {call = SignUp},
    collect_configs = {call = CollectConfigs},

    read_ispapp_config = {call = function() return get_config() end},
    write_ispapp_config = {
        args = {config = "table"},
        call = function(args) return set_config(args.config) end
    },
    check_ispapp_status = {
        call = function() return exec_command("/sbin/logread -e ispapp") end
    },
    reload_ispapp = {call = function() return manage_service("reload") end},
    restart_ispapp = {call = function() return manage_service("restart") end},
    suspend_ispapp = {call = function() return manage_service("suspend") end},
    resume_ispapp = {call = function() return manage_service("resume") end},
    query_ispapp = {call = function() return query_service() end},
    read_pid_file = {
        call = function() return read_file("/var/run/ispapp.pid") end
    },
    read_runtime_file = {
        call = function() return read_file("/tmp/ispapp_runtime.json") end
    },
    read_crontab = {
        call = function() return read_file("/etc/crontabs/root") end
    },
    get_last_edit_time = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({last_edit_time = get_last_edit_time()})
            return r
        end
    },
    get_active_time = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({active_time = get_active_time()})
            return r
        end
    },
    get_cpu_usage = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({cpu_usage = get_cpu_usage()})
            return r
        end
    },
    get_device_mode = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({device_mode = get_device_mode()})
            return r
        end
    }
}

local function parseInput()
    local parse = jsonc.new()
    local done, err

    while true do
        local chunk = io.read(4096)
        if not chunk then
            break
        elseif not done and not err then
            done, err = parse:parse(chunk)
        end
    end

    if not done then
        print(jsonc.stringify({
            error = err or "Incomplete input for argument parsing"
        }))
        os.exit(1)
    end

    return parse:get()
end

local function validateArgs(func, uargs)
    local method = methods[func]
    if not method then
        print(jsonc.stringify({error = "Method not found in methods table"}))
        os.exit(1)
    end

    local n = 0
    for _, _ in pairs(uargs) do n = n + 1 end

    if method.args and n == 0 then
        print(jsonc.stringify({
            error = "Received empty arguments for " .. func ..
                " but it requires " .. jsonc.stringify(method.args)
        }))
        os.exit(1)
    end

    uargs.ubus_rpc_session = nil

    local margs = method.args or {}
    for k, v in pairs(uargs) do
        if margs[k] == nil or (v ~= nil and type(v) ~= type(margs[k])) then
            print(jsonc.stringify({
                error = "Invalid argument '" .. k .. "' for " .. func ..
                    " it requires " .. jsonc.stringify(method.args)
            }))
            os.exit(1)
        end
    end

    return method
end

if arg[1] == "list" then
    local _, rv = nil, {}
    for _, method in pairs(methods) do rv[_] = method.args or {} end
    print((jsonc.stringify(rv):gsub(":%[%]", ":{}")))
elseif arg[1] == "call" then
    local args = parseInput()
    local method = validateArgs(arg[2], args)
    local run = method.call(args)
    print(run.result)
    os.exit(run.code or 0)
elseif arg[1] == "help" then
    local helptext = [[
Usage:

 To see what methods are exported by this script:

    lua luci.ispapp list

 To call a method that has no arguments:

    echo '{}' | lua luci.ispapp call method_name

 To call a method that takes arguments:

    echo '{"valid": "json", "argument": "value"}' | lua luci.ispapp call method_name

 To call this script via ubus:

    ubus call luci.example method_name '{"valid": "json", "argument": "value"}'
]]
    print(helptext)
end
