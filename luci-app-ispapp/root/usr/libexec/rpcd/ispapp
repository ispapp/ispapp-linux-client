#!/usr/bin/env lua

-- ispapp ubus api
-- path: /usr/libexec/rpcd/ispapp
local jsonc = require "luci.jsonc"
local nixio = require "nixio"
local fs = require "nixio.fs"
local UCI = require "luci.model.uci"
local util = require "luci.util"
local sys = require "luci.sys"
local ubus = require "ubus"
local md5 = require "md5c"
local https = require("ssl.https")
local ltn12 = require("ltn12")
local http = require "socket.http"

local conn = ubus.connect()
if not conn then
    error("Failed to connect to ubus")
end
local uci = UCI.cursor()
local function count_keys(tbl)
    local count = 0
    for _, _ in pairs(tbl) do
        count = count + 1
    end
    return count
end
local function log_to_syslog(level, message)
    nixio.syslog(level, message)
end
-- priority Priority ["emerg", "alert", "crit", "err", "warning", "notice", "info", "debug"] 
local function log_error(message)
    log_to_syslog("err", "[luci.ispapp]: " .. message)
end
local function log_info(message)
    log_to_syslog("info", "[luci.ispapp]: " .. message)
end
-- local function log_warning(message)
--     log_to_syslog("info", "[luci.ispapp]: " .. message)
-- end
-- local function log_notice(message)
--     log_to_syslog("info", "[luci.ispapp]: " .. message)
-- end
-- return file content or nil
local function catFile(file)
    local ok, content, error = pcall(fs.readfile, file)
    if not ok then
        return nil
    end
    return content
end

-- Function to parse spectral data
local function parse_spectral_data(filepath)
    local data = {
        header = {},
        spectral_caps = {},
        spectral_params = {},
        samples = {}
    }
    local function format_sample_csv(sample_array)
        -- Convert array of values to CSV string
        local csv_parts = {}
        for _, value in ipairs(sample_array) do
            if type(value) == "number" then
                table.insert(csv_parts, tostring(value))
            else
                table.insert(csv_parts, value)
            end
        end
        return table.concat(csv_parts, ",")
    end

    local current_section = "header"
    local file = io.open(filepath, "r")
    if not file then
        return {}
    end

    -- Skip header comment lines
    local _ = file:read("*line")
    local _ = file:read("*line")

    local in_sample_header = false

    for line in file:lines() do
        -- Process non-empty lines
        if not line:match("^%s*$") then
            -- Handle section changes
            if line == "spectral_caps" then
                current_section = "spectral_caps"
            elseif line == "spectral_params" then
                current_section = "spectral_params"
            elseif line:match("^S.No") then
                current_section = "samples"
                in_sample_header = true
                -- Skip sample format description lines
            elseif not (in_sample_header and (line:match("^%s+Span_id") or line:match("^%s+Detector_id"))) then
                -- In your parse function, modify the samples handling:
                if current_section == "samples" and not in_sample_header then
                    -- Parse sample data
                    local sample = {}
                    for value in line:gmatch("[^,]+") do
                        value = value:match("^%s*(.-)%s*$") -- trim whitespace
                        if value:match("^-?%d+$") then
                            table.insert(sample, tonumber(value))
                        else
                            table.insert(sample, value)
                        end
                    end
                    if #sample > 0 then
                        -- Convert sample array to CSV string
                        table.insert(data.samples, format_sample_csv(sample))
                    end
                else
                    -- Parse key-value pairs
                    local key, value = line:match("([^,]+):%s*,(.+)")
                    if key and value then
                        if value:match("^-?%d+$") then
                            value = tonumber(value)
                        end
                        data[current_section][key] = value
                    else
                        in_sample_header = false
                    end
                end
            end
        end
    end

    file:close()
    return data
end
-- parse_spectral_data and return the result
local function get_spectral_data(inter)
    local ok, _, _ = pcall(util.exec, string.format("spectraltool -i %s get_samples 100 -x 1 -l ','", inter))
    local parsed, json, _ = pcall(parse_spectral_data, "./outFile")
    if not parsed or not ok then
        return {
            error = "Failed to parse spectral data.",
            ok = true
        }
    end
    return {
        result = json,
        ok = ok
    }
end
-- Function to make an HTTP request and ignore SSL verification
local function getRequest(url, timeout, auth)
    local string_sub = string.sub
    local table_concat = table.concat
    http.TIMEOUT = timeout or 5
    http.USERAGENT =
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.97 Safari/537.36"
    local b, c, h, s
    local tbody = {}
    local headers = {
        ["Accept"] = "*/*",
        ["Accept-Language"] = "sk;q=0.8,en-US,en;q=0.6,cs;q=0.4",
        ["Accept-Charset"] = "UTF-8;q=0.8,*;q=0.7"
    }
    if auth then
        local accessToken = uci:get("ispapp", "@settings[0]", "accessToken")
        if accessToken and accessToken ~= "" then
            headers["Authorization"] = 'Bearer ' .. accessToken
        end
    end
    local https_opt = {
        url = url,
        protocol = "tlsv1_2",
        verify = "none",
        headers = headers,
        sink = ltn12.sink.table(tbody),
        redirect = false
    }
    local http_opt = {
        url = url,
        headers = headers,
        sink = ltn12.sink.table(tbody),
        redirect = false
    }
    if string_sub(url, 1, 5) ~= "https" then
        _, c, h, s = http.request(http_opt)
    else
        _, c, h, s = https.request(https_opt)
    end
    -- make headers keys lowercase
    if h ~= nil then
        local h_tmp = {}
        for k, v in pairs(h) do
            h_tmp[k:lower()] = v
        end
        h = h_tmp
    end
    -- concat body parts
    b = table_concat(tbody)
    return {
        body = b,
        code = c,
        headers = h,
        status = s
    }
end
-- Function to make a POST request with optional JSON body, authorization, and parameters
local function postRequest(url, data, timeout)
    local string_sub = string.sub
    local table_concat = table.concat
    local request_body = data and jsonc.stringify(data) or ""
    http.TIMEOUT = timeout or 5
    http.USERAGENT =
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.97 Safari/537.36"
    local b, c, h, s
    local tbody = {}
    local headers = {
        ["Accept"] = "*/*",
        ["Accept-Language"] = "sk;q=0.8,en-US,en;q=0.6,cs;q=0.4",
        ["Accept-Charset"] = "UTF-8;q=0.8,*;q=0.7",
        ["Content-Type"] = "application/json",
        ["Content-Length"] = #request_body
    }
    -- headers for access
    local accessToken = uci:get("ispapp", "@settings[0]", "accessToken")
    if accessToken and accessToken ~= "" then
        headers["Authorization"] = 'Bearer ' .. accessToken
    end
    local https_opt = {
        url = url,
        protocol = "tlsv1_2",
        verify = "none",
        method = "POST",
        source = ltn12.source.string(request_body),
        headers = headers,
        sink = ltn12.sink.table(tbody),
        redirect = false
    }
    local http_opt = {
        url = url,
        method = "POST",
        source = ltn12.source.string(request_body),
        headers = headers,
        sink = ltn12.sink.table(tbody),
        redirect = false
    }
    if string_sub(url, 1, 5) ~= "https" then
        _, c, h, s = http.request(http_opt)
    else
        _, c, h, s = https.request(https_opt)
    end
    -- make headers keys lowercase
    if h ~= nil then
        local h_tmp = {}
        for k, v in pairs(h) do
            h_tmp[k:lower()] = v
        end
        h = h_tmp
    end
    -- concat body parts
    b = table_concat(tbody)
    return {
        body = b,
        code = c,
        headers = h,
        status = s
    }
end
local getKey = function(device)
    local key = "N/A"
    if string.find(device, "mld") then
        uci:foreach("wireless", "wifi-iface", function(section)
            if section.mld == device then
                if key == "N/A" then
                    key = section.key or section.sae_password or "N/A"
                end
            end
        end)
    end
    if key == "N/A" then
        uci:foreach("wireless", "wifi-iface", function(section)
            if section.device == device then
                if key == "N/A" then
                    key = section.key or section.sae_password or "N/A"
                    if key == "N/A" then
                        local keyfile = section.priv_key and catFile(section.priv_key)
                        if keyfile then
                            key = keyfile .. section.priv_key_password
                        end
                    end
                end
            end
        end)
    end
    if type(key) == "table" then
        key = key[0] or key[1]
    end
    return key
end
local getEncryption = function(device)
    local keytypes = ""
    if string.find(device, "mld") then
        uci:foreach("wireless", "wifi-iface", function(section)
            if section.mld == device then
                if keytypes == "" then
                    keytypes = section.encryption or "none"
                    if type(section.encryption) == "table" then
                        keytypes = section.encryption[0] or section.encryption[1] or "none"
                    end
                end
            end
        end)
    end
    if keytypes == {} then
        uci:foreach("wireless", "wifi-iface", function(section)
            if section.device == device then
                if keytypes == "" then
                    keytypes = section.encryption or "none"
                    if type(section.encryption) == "table" then
                        keytypes = section.encryption[0] or section.encryption[1] or "none"
                    end
                end
            end
        end)
    end
    return keytypes
end

local function read_file(path)
    local file, err = fs.readfile(path)
    if not file then
        log_error("Failed to read file " .. path .. ": " .. err)
        return {
            error = "Failed to read file."
        }
    end
    return {
        result = file,
        error = err
    }
end

local function exec_command(cmd)
    local ok, _, _ = pcall(util.exec, cmd)
    return {
        result = ok
    }
end

local function manage_service(action)
    local cmd = "/etc/init.d/ispapp " .. action
    return exec_command(cmd)
end

local function query_service()
    local cmd = "/etc/init.d/ispapp query *"
    return exec_command(cmd)
end

local function get_last_edit_time()
    local stat = fs.stat("/etc/config/ispapp")
    if stat and stat.mtime then
        return os.date("%Y-%m-%d %H:%M:%S", tonumber(stat.mtime))
    end
    return "N/A"
end

local function get_active_time()
    local datetime = sys.exec("date +'%Y-%m-%d %H:%M:%S'"):gsub("\n", "") -- Execute the command
    return datetime or "N/A" -- Return the result or "N/A" if the command fails
end

local function set_config(data)

    -- Apply configuration changes to '@settings[0]' section
    uci:set("ispapp", "@settings[0]", "enabled", data.enabled or '')
    uci:set("ispapp", "@settings[0]", "login", data.login or '')
    uci:set("ispapp", "@settings[0]", "Domain", data.Domain or '')
    uci:set("ispapp", "@settings[0]", "ListenerPort", data.ListenerPort or '')
    -- uci:set("ispapp", "@settings[0]", "SmtpPort", data.SmtpPort or '')
    uci:set("ispapp", "@settings[0]", "Key", data.Key or '')
    -- uci:set("ispapp", "@settings[0]", "ipbandswtestserver", data.ipbandswtestserver or '')
    -- uci:set("ispapp", "@settings[0]", "btuser", data.btuser or '')
    -- uci:set("ispapp", "@settings[0]", "btpwd", data.btpwd or '')

    local success, err = uci:commit("ispapp")
    if not success then
        log_error("Failed to commit changes to /etc/config/ispapp: " .. err)
        return {
            error = "Failed to save configuration."
        }
    end

    return {
        result = "Configuration saved successfully."
    }
end
-- verify config and make sure it's exist and filled with defaults if necessary
local function verify_config()
    local config = "ispapp"
    local section = "@settings[0]"

    -- Check if the ispapp config file and section exists
    if not uci:get(config, section) then
        -- Create the 'config' section with default options if it doesn't exist
        set_config({
            enabled = '0',
            login = '00000000-0000-0000-0000-000000000000',
            Domain = 'prv.longshot-router.com',
            ListenerPort = '443',
            Key = '',
            accessToken = '',
            refreshToken = '',
            connected = '0'
        })
        -- Commit the changes after creating the config
        uci:commit(config)
        return {
            result = "Configuration created successfully."
        }
    end
    return {
        result = "Configuration already exists."
    }
end

-- this function will check a list of file related to the ispapp service
-- and update them if the sumhash is not the same as the one in github repo corresponding files.
local function sync_agent_version()
    local branch = "skynet"
    local base_uri = "http://github.com/ispapp/ispapp-linux-client/raw/refs/heads/" .. branch .. "/luci-app-ispapp"
    local remote_agent_files = {
        logread = "/htdocs/luci-static/resources/view/ispapp/logread.js",
        overview = "/htdocs/luci-static/resources/view/ispapp/overview.js",
        settings = "/htdocs/luci-static/resources/view/ispapp/settings.js",
        ispappcontroller = "/luasrc/controller/ispapp.lua",
        rpcd = "/root/usr/libexec/rpcd/ispapp",
    }
    local local_agent_files = {
        logread = "/www/luci-static/resources/view/ispapp/logread.js",
        overview = "/www/luci-static/resources/view/ispapp/overview.js",
        settings = "/www/luci-static/resources/view/ispapp/settings.js",
        ispappcontroller = "/usr/lib/lua/luci/controller/ispapp.lua",
        rpcd = "/usr/libexec/rpcd/ispapp",
    }
    local updated_files = {}
    for key, file in pairs(remote_agent_files) do
        local remote_file = base_uri .. file
        local local_file = local_agent_files[key]
        local remote_content = sys.httpget(remote_file, false)
        -- print(remote_content)
        if remote_content then
            local remote_tmp_file = "/tmp/remote_" .. key .. ".tmp"

            -- Write remote content to temporary file
            local remote_file_content = io.open(remote_tmp_file, "w")
            if remote_file_content ~= nil then
                remote_file_content:write(remote_content)
                remote_file_content:close()
            end

            -- Calculate SHA256 sums
            local remote_hash = sys.exec("sha256sum " .. remote_tmp_file .. " | awk '{print $1}'")
            local local_hash = sys.exec("sha256sum " .. local_file .. " | awk '{print $1}'")

            print(remote_hash)
            print(local_hash)
            if remote_hash ~= local_hash then
                local updated = fs.writefile(local_file, remote_content)
                if updated then
                    -- add collored checkmark or red cross
                    print("✔️"..file)
                    table.insert(updated_files, local_file)
                else 
                    print("❌"..file)
                end
            end
             -- Remove temporary files
             os.remove(remote_tmp_file)
        end
    end
    local login = uci:get("ispapp", "@settings[0]", "login")
    local domain = uci:get("ispapp", "@settings[0]", "Domain")
    local loaded = {}
    if not domain or domain == "" then
        local ok,_domain,_ = pcall(sys.exec, "fw_printenv prvdomain")
        if ok and _domain then
            _domain = _domain:gsub("prvdomain=", "")
            uci:set("ispapp", "@settings[0]", "Domain", _domain)
        else
            uci:set("ispapp", "@settings[0]", "Domain", "prv.cloud.ispapp.co")
        end
    end
    if not login or login == "" or login == "00000000-0000-0000-0000-000000000000" then
        -- fw_printenv return somehting like login=00000000-0000-0000-0000-000000000000
        local _login = sys.exec("fw_printenv login"):gsub("login=", "")
        if _login then
            uci:set("ispapp", "@settings[0]", "login", _login)
            loaded["login"] = _login
        end
    end
    local port = uci:get("ispapp", "@settings[0]", "ListenerPort")
    local init_req = string.format('https://%s:%s/upgrade_done', domain, port)
    -- post all the updated files to the server
    local post_data = {
        files = updated_files,
        timestamp = os.time()
    }
    local ok, post_response, _ = pcall(postRequest, init_req, post_data, 5)
    return {
        result = "Agent version synced successfully.",
        updated_files = updated_files,
        update_reported = ok,
        post_response = post_response
    }
end
-- run verify_configs function to make sure all ok
-- verify_config()
-- if not fill them with default values from fw_printenv command
local function reload_envirement()
    local login = uci:get("ispapp", "@settings[0]", "login")
    local key = uci:get("ispapp", "@settings[0]", "Key")
    local domain = uci:get("ispapp", "@settings[0]", "Domain")
    local loaded = {}
    if not domain or domain == "" then
        local _domain = sys.exec("fw_printenv prvdomain"):gsub("prvdomain=", "")
        if _domain then
            uci:set("ispapp", "@settings[0]", "Domain", _domain)
            loaded["domain"] = _domain
        else
            uci:set("ispapp", "@settings[0]", "Domain", "prv.cloud.ispapp.co")
        end
    end
    if not login or login == "" or login == "00000000-0000-0000-0000-000000000000" then
        -- fw_printenv return somehting like login=00000000-0000-0000-0000-000000000000
        local _login = sys.exec("fw_printenv login"):gsub("login=", "")
        if _login then
            uci:set("ispapp", "@settings[0]", "login", _login)
            loaded["login"] = _login
        end
    end
    if not key or key == "" then
        local _key = sys.exec("fw_printenv key"):gsub("key=", "")
        if _key then
            uci:set("ispapp", "@settings[0]", "Key", _key)
            loaded["key"] = _key
        end
    end
    uci:commit("ispapp")
    return loaded
end
-- save the login, key and domain to the envirement
local save_to_envirement = function(data)
    local login = uci:get("ispapp", "@settings[0]", "login")
    local key = uci:get("ispapp", "@settings[0]", "Key")
    local domain = uci:get("ispapp", "@settings[0]", "Domain")
    local saved = {}
    if login and login ~= "" and login ~= "00000000-0000-0000-0000-000000000000" then
        sys.exec("fw_setenv login " .. login)
        saved["login"] = login
    end
    if key and key ~= "" then
        sys.exec("fw_setenv key " .. key)
        saved["key"] = key
    end
    if domain and domain ~= "" then
        local ok,_domain,_ = pcall(sys.exec, "fw_printenv prvdomain")
        if ok and _domain then
            saved["domain"] = domain
        end
    end
    return saved
end
-- local sys = require("luci.sys") -- Make sure to import sys

-- Function to get formatted process info by PID
local function get_process_info(pid)
    -- Read /proc/[pid]/statm for memory information
    local statm_file = string.format("pidstat -p %s | awk 'NR>3 {print $8}' | tr -d '\n'", pid)
    local ok, statm_content = pcall(sys.exec, statm_file)
    if ok then
        return {
            result = statm_content
        }
    else
        return {
            error = "N/A%"
        }
    end
end

local function get_device_mode()
    local mode_count = {}

    -- Iterate over all wireless interfaces
    uci:foreach("wireless", "wifi-iface", function(section)
        if section.mode then
            local mode = section.mode
            -- Count occurrences of each mode
            mode_count[mode] = (mode_count[mode] or 0) + 1
        end
    end)
    -- Determine the majority mode
    local majority_mode, max_count = nil, 0
    for mode, count in pairs(mode_count) do
        if count > max_count then
            majority_mode = mode
            max_count = count
        end
    end

    -- Return the majority mode or a default value if none found
    return majority_mode or "N/A"
end

local function get_config()
    local sections = uci:get_all("ispapp", "@settings[0]")
    return sections
end

-- Function to check if a command exists
local function commandExists(command)
    return sys.exec("which " .. command) ~= "" and true or false
end

-- Function to extract a value by key from the release info
local function getReleaseValue(key)
    -- Read the content of /etc/openwrt_release
    local release_info = sys.exec("cat /etc/openwrt_release")
    local pattern = key .. "='(.-)'"
    return release_info:match(pattern)
end

-- get the cupi information fro the file system 
local function getCPUInfo()
    -- Execute the command to get the content of /proc/cpuinfo
    local cpuinfo = sys.exec("cat /proc/cpuinfo")

    local core_count = 0
    local model_name = ""

    -- Iterate through each line of /proc/cpuinfo
    for line in cpuinfo:gmatch("[^\r\n]+") do
        -- Check for processor lines to count the cores
        if line:find("^processor%s*:%s*%d+") then
            core_count = core_count + 1
        end

        -- Check for model name
        if line:find("^model name%s*:%s*") then
            model_name = line:match("^model name%s*:%s*(.+)")
        end
    end

    -- Return the number of cores and the model name
    return core_count, model_name
end

local function getHardwareSerialNumber()
    local ok, serialnumber, err = pcall(sys.exec, "fw_printenv sn")
    if ok and not err then
        local sn = serialnumber:match("sn=(%S+)") or ""
        if sn ~= "" then
            return sn
        end
    end
    -- cat /proc/cpuinfo
    local cpuinfo = sys.exec("cat /proc/cpuinfo")
    local serial = cpuinfo:match("Serial%s*:%s*(%S+)")
    if serial then
        return serial
    end
    return serial or "N/A"
end

-- Function to extract a value by key from the hardware info
local function getBoardInfo()
    -- check if /etc/img_version exist and get data with : as split char and those data as returns
    -- manufacturer,version,model,env and get serial number from fw_printenv sn command after = sign
    -- and if not exist we take 
    -- cat /etc/device_info
    -- DEVICE_MANUFACTURER='OpenWrt'
    -- DEVICE_MANUFACTURER_URL='https://openwrt.org/'
    -- DEVICE_PRODUCT='Generic'
    -- DEVICE_REVISION='v0'
    -- and serial number from cat /etc/board.json , model.id or from /proc/cpuinfo Serial
    local board_info = {}
    local _file = io.open("/etc/img_version")
    if _file ~= nil then
        local img_version = _file:read("*a")
        local ok, sn, _ = pcall(sys.exec, "fw_printenv sn")
        if ok and sn then
            sn = sn:match("sn=(%S+)") or "N/A"
        else
            ok, sn, _ = pcall(sys.exec, "fw_printenv soc_hw_version")
            if ok and sn then
                sn = sn:match("soc_hw_version=(%S+)") or "N/A"
            else
                sn = 'N/A'
            end
        end
        board_info = {
            hardwareMake = img_version:match("manufacturer:(%S+)") or "N/A",
            hardwareModelNumber = img_version:match("model:(%S+)") or "N/A",
            hardwareModel = img_version:match("model:(%S+)") or "N/A",
            hardwareSerialNumber = sys.exec("fw_printenv sn"):match("sn=(%S+)") or "N/A",
        }
    else
        local device_info = catFile("/etc/device_info")
        if device_info then
            board_info = {
                hardwareMake = device_info:match("DEVICE_MANUFACTURER='(%S+)'") or "N/A",
                hardwareModelNumber = device_info:match("DEVICE_REVISION='(%S+)'") or "N/A",
                hardwareModel = device_info:match("DEVICE_PRODUCT='(%S+)'") or "N/A",
                hardwareSerialNumber = getHardwareSerialNumber()
            }
        end
    end
    return board_info or {}
end

-- Single function to fetch interfaces, check for bridge memberships, and gather network stats
local function getNetworkInterfaces()
    local interfaces = {}

    -- Ensure the ubus connection is established
    if not conn then
        return nil, "Failed to connect to ubus"
    end

    -- Function to get bridge members for a specific bridge (e.g., br-lan)
    local function getBridgeMembers(bridge)
        local bridgeStatus = conn:call("network.device", "status", {
            name = bridge
        })
        return bridgeStatus['bridge-members'] or {}
    end

    -- Fetch all network devices using 'network.device' from ubus
    local devices = conn:call("network.device", "status", {})

    -- Track which interfaces belong to which bridges
    local bridgeMembers = {}

    -- Check for any bridges and fetch their members
    for iface, data in pairs(devices) do
        if data.type == "bridge" then
            local members = getBridgeMembers(iface)
            for _, member in ipairs(members) do
                bridgeMembers[member] = iface -- Map bridge members to the bridge (master interface)
            end
        end
    end

    -- Iterate over each device (interface)
    for iface, data in pairs(devices) do
        local mac = data.macaddr or "00:00:00:00:00:00" -- Default to all zeros if MAC is missing

        -- If no MAC address is present, skip this interface
        if mac ~= nil then
            -- Check if the interface is part of a bridge and assign the bridge as the default interface
            local defaultIf = bridgeMembers[iface] or iface

            -- Extract network statistics from the 'statistics' table in the ubus data
            local stats = data.statistics or {}

            -- Add the interface with its stats to the table
            local link_speed = tonumber(catFile("/sys/class/net/" .. iface .. "/speed") or 0)
            link_speed = link_speed > 0 and link_speed or 0
            table.insert(interfaces, {
                defaultIf = defaultIf, -- Set to bridge if part of a bridge, otherwise use iface
                ["if"] = iface,
                mac = mac, -- Keep MAC address even if it is '00:00:00:00:00:00'
                recBytes = stats.rx_bytes or 0,
                sentBytes = stats.tx_bytes or 0,
                recPackets = stats.rx_packets or 0,
                sentPackets = stats.tx_packets or 0,
                recErrors = stats.rx_errors or 0,
                link_speed = link_speed,
                sentErrors = stats.tx_errors or 0,
                recDrops = stats.rx_dropped or 0,
                sentDrops = stats.tx_dropped or 0,
                carrierChanges = tonumber(catFile("/sys/class/net/" .. iface .. "/carrier_changes") or 0) or 0, -- Use tx_carrier_errors for carrier change stats
                foundDescriptor = catFile("/sys/class/net/" .. iface .. "/uevent"):match("DEVTYPE=(%w+)") or "N/A"
            })
        end
    end

    -- Return the list of interfaces
    return interfaces
end

-- Function to get external IP info and fill missing fields with "N/A"
local function getExternalIpInfo()
    -- Perform an HTTP GET request using luci.sys.httpget and fetch the JSON response as a string
    local jsonString = sys.httpget("http://ip.longshot-router.com/json", false)
    -- return jsonString
    -- {"timestamp":"2024-12-19T01:40:49.236Z","continent":"AF","longitude":"-7.61330","latitude":"33.57920","country":"MA","city":"Casablanca","region":"Casablanca-Settat","regionCode":"06","timezone":"Africa/Casablanca","asn":{"asn":36925,"entities":[{"type":"vcard","version":"4.0","kind":"individual","fn":"ISP Orange Morocco","tel":"tel:+212-665-551000","email":"isp_oma@orange.ma","adr":{"label":"Immeuble MEDITEL (ex SICOTEL)\nLa Colline 2 2eme Etage Sidi Maarouf 20190\nCasablanca Maroc\nCasablanca 20190\nMorocco","details":["Immeuble MEDITEL (ex SICOTEL)","La Colline 2 2eme Etage Sidi Maarouf 20190","Casablanca Maroc","Casablanca 20190","Morocco","",""]}},{"type":"vcard","version":"4.0","kind":"org","fn":"MEDITELECOM","tel":"tel:+212-665-551000","email":"isp_oma@orange.ma","adr":{"label":"Immeuble MEDITEL (ex SICOTEL)\nLa Colline 2 2eme Etage Sidi Maarouf 20190\nCasablanca Maroc\nCasablanca 20190","details":["Immeuble MEDITEL (ex SICOTEL)","La Colline 2 2eme Etage Sidi Maarouf 20190","Casablanca Maroc","Casablanca 20190","","",""]}}]},"botscore":99,"userAgent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0","realIp":"196.113.44.89","ip":"196.113.44.89"}
    -- Initialize a table with "N/A" as default values
    local info = {
        ip = "N/A",
        country = "N/A",
        city = "N/A",
        asn = "N/A",
        region_name = "N/A",
        region_code = "N/A",
        time_zone = "N/A",
        latitude = 0,
        longitude = 0,
        country_iso = "N/A"
    }

    -- Try to parse the JSON data if jsonString is not nil or empty
    if jsonString and jsonString ~= "" then
        local parsedData = jsonc.parse(jsonString)
        local getFullAsn = function(asnData)
            if type(asnData) == "table" then
                local asn = asnData.asn or "N/A"
                local entities = asnData.entities or {}
                local entityNames = {}
                for _, entity in ipairs(entities) do
                    local fn = entity.fn .. " (" .. (entity.type or "N/A") .. ")"
                    table.insert(entityNames, fn)
                end
                return asn .. " (" .. table.concat(entityNames, ", ") .. ")"
            else
                return "N/A"
            end
        end
        -- Check if JSON parsing is successful and then extract data
        if parsedData then
            info.ip = parsedData.realIp or "N/A"
            info.country = parsedData.country or "N/A"
            info.city = parsedData.city or "N/A"
            info.asn = getFullAsn(parsedData.asn) or "N/A"
            info.region_name = parsedData.region or "N/A"
            info.region_code = parsedData.regionCode or "N/A"
            info.time_zone = parsedData.timezone or "N/A"
            info.latitude = tonumber(parsedData.latitude) or 0
            info.longitude = tonumber(parsedData.longitude) or 0
            info.country_iso = parsedData.country_iso or "N/A"
        end
    end

    -- Return the info table, ignoring any errors
    return info
end
-- Channel to frequency conversion table
local function get_frequency_from_channel(channel)
    if channel <= 14 then
        -- 2.4 GHz channels
        return 2407 + (channel * 5)
    else
        -- 5 GHz channels
        return 5000 + (channel * 5)
    end
end
local function parse_bss_scan(device)
    local scan_data = {}
    local current_bss = nil

    local handle = io.popen("iw dev " .. device .. " scan dump")
    if not handle then
        return {}
    end

    for line in handle:lines() do
        local bss = line:match("^BSS ([0-9a-fA-F:]+)")
        if bss then
            if current_bss then
                table.insert(scan_data, current_bss)
            end
            current_bss = {
                bssid = bss,
                freq = nil,
                beacon_interval = nil,
                capability = nil,
                signal = nil,
                ssid = nil,
                security = {
                    type = nil,
                    group_cipher = nil,
                    pairwise_ciphers = {},
                    auth_suites = {}
                },
                ht = {
                    capabilities = nil,
                    max_ampdu_length = nil,
                    channel = nil,
                    channel_width = nil
                },
                vht = {
                    capabilities = nil,
                    channel_width = nil,
                    mcs_set = {}
                },
                he = {
                    mac_capabilities = nil,
                    phy_capabilities = nil
                }
            }
        elseif current_bss then
            -- Parse basic info
            local freq = line:match("freq:%s+(%d+)")
            local signal = line:match("signal:%s+([-%.%d]+)")
            local ssid = line:match("SSID:%s+(.*)")
            local beacon = line:match("beacon interval:%s+(%d+)")

            if freq then
                current_bss.freq = tonumber(freq)
            end
            if signal then
                current_bss.signal = tonumber(signal)
            end
            if ssid then
                current_bss.ssid = ssid
            end
            if beacon then
                current_bss.beacon_interval = tonumber(beacon)
            end

            -- Parse security info
            if line:match("^%s+RSN:") then
                current_bss.security.type = "RSN"
            end

            -- Parse HT/VHT/HE capabilities
            if line:match("^%s+HT capabilities:") then
                local cap = line:match("Capabilities:%s+0x(%x+)")
                if cap then
                    current_bss.ht.capabilities = "0x" .. cap
                end
            end

            if line:match("^%s+VHT capabilities:") then
                local cap = line:match("VHT Capabilities%s+%(0x(%x+)%)")
                if cap then
                    current_bss.vht.capabilities = "0x" .. cap
                end
            end

            if line:match("^%s+HE capabilities:") then
                local mac_cap = line:match("HE MAC Capabilities%s+%(0x(%x+)%)")
                if mac_cap then
                    current_bss.he.mac_capabilities = "0x" .. mac_cap
                end
            end
        end
    end

    if current_bss then
        table.insert(scan_data, current_bss)
    end

    handle:close()
    return scan_data
end
-- calculate estimated distance based on formula call Free Space Path Loss
local function estimate_distance(signal_dbm, channel)
    -- Convert channel to frequency
    local frequency_mhz = get_frequency_from_channel(channel)

    -- Free Space Path Loss formula
    local freq_log = math.log10(frequency_mhz)
    local abs_signal = math.abs(signal_dbm)

    -- Calculate estimated distance in meters
    local distance = 10 ^ ((27.55 - (20 * freq_log) + abs_signal) / 20)

    return math.floor(distance)
end

local function GetwifiScan()
    local interfaces = conn:call("iwinfo", "devices", {})
    -- sort the interfaces by name alphabetically
    local capable_of_scanning = {}
    local seen_frequencies = {}
    for _, iface in ipairs(interfaces.devices) do
        local info = conn:call("iwinfo", "info", {
            device = iface
        })
        if info and info['frequency'] then
            local freq_key = math.floor(info.frequency / 1000)
            if not seen_frequencies[freq_key] then
                table.insert(capable_of_scanning, {
                    frequency = tonumber(info.frequency),
                    device = iface
                })
                seen_frequencies[freq_key] = true
            end
        end
    end
    table.sort(capable_of_scanning, function(a, b)
        return a.device < b.device
    end)
    local stations = {}
    for _, iface in pairs(capable_of_scanning) do
        local tmpdata = {
            radio_scaning = iface,
            found_stations = {}
        }
        local scan = conn:call("iwinfo", "scan", {
            device = iface.device
        })
        local avoidrepeat = {}
        for _, station in pairs(scan.results) do
            -- calculate istimated distance
            -- using the formula called Free Space Path Loss
            if not avoidrepeat[station.bssid] then
                avoidrepeat[station.bssid] = true
                station.estimated_distance = estimate_distance(station.signal, station.channel)
                table.insert(tmpdata.found_stations, station)
            end
        end
        table.insert(stations, tmpdata)
    end
    return stations
end
-- Function to parse /etc/os-release and return information as a Lua table
local function parseOsRelease()
    local osReleasePath = "/etc/os-release"
    local osInfo = {
        NAME = "N/A",
        VERSION = "N/A",
        ID = "N/A",
        ID_LIKE = "N/A",
        PRETTY_NAME = "N/A",
        VERSION_ID = "N/A",
        HOME_URL = "N/A",
        BUG_URL = "N/A",
        SUPPORT_URL = "N/A",
        BUILD_ID = "N/A",
        OPENWRT_BOARD = "N/A",
        OPENWRT_ARCH = "N/A",
        OPENWRT_TAINTS = "N/A",
        OPENWRT_DEVICE_MANUFACTURER = "N/A",
        OPENWRT_DEVICE_MANUFACTURER_URL = "N/A",
        OPENWRT_DEVICE_PRODUCT = "N/A",
        OPENWRT_DEVICE_REVISION = "N/A",
        OPENWRT_RELEASE = "N/A"
    }

    -- Check if the file exists
    if fs.access(osReleasePath) then
        -- Read the file contents
        local fileContent = fs.readfile(osReleasePath)
        if fileContent and fileContent ~= "" then
            -- Split content into lines
            for line in fileContent:gmatch("[^\r\n]+") do
                -- Split each line into key and value
                local key, value = line:match("^(%S+)=\"?(.*)\"?$")
                if key and value then
                    osInfo[key] = value:gsub('\"$', "") -- Store the value in the osInfo table
                end
            end
        end
    end

    return osInfo
end

-- Function to collect security profiles of all wireless interfaces from UCI
local function collectSecurityProfiles()
    local profiles = {}

    -- Create a table to map device section to MAC address, hwmode, and htmode
    local device_info = {}

    -- Get all wireless device and interface sections
    -- uci:foreach("wireless", "wifi-device", function(section)
    --     device_info[section[".name"]] = {macaddr = section.macaddr or "N/A"}
    -- end)
    -- Get the hostname for the supplicant-identity
    -- local hostname = sys.hostname()
    uci:foreach("wireless", "wifi-iface", function(section)
        local profile = {
            [".id"] = "*" .. tostring(section['.index']), -- Use index as ID for the profile
            ["name"] = tostring(section['.name']),
            ["authentication-types"] = {section.encryption or "none"}, -- Directly use section.encryption
            -- name = section.ssid or "N/A", -- Use SSID or default
            -- ["supplicant-identity"] = hostname, -- Set supplicant-identity to the hostname
            technology = "wireless"
        }
        if section.sae_password then
            if type(section.key) == "string" then
                profile["wpa3-pre-shared-key"] = section.sae_password or ""
            else
                profile["wpa3-pre-shared-key"] = section.sae_password[0] or section.sae_password[1] or ""
            end
        end
        if section.key then
            if type(section.key) == "string" then
                profile["wpa-pre-shared-key"] = section.key or ""
                profile["wpa2-pre-shared-key"] = section.key or ""
            else
                profile["wpa-pre-shared-key"] = section.key[0] or section.key[1] or ""
                profile["wpa2-pre-shared-key"] = section.key[0] or section.key[1] or ""
            end
        end
        -- Get device information from the corresponding wifi-device section
        local device_name = section.device or "default" -- Get the device name associated with the iface
        -- local device_details = device_info[device_name] or
        --                            {
        --         macaddr = "N/A",
        --         hwmode = "N/A",
        --         htmode = "N/A"
        --     }
        -- -- Add MAC address, hwmode, and htmode to the profile
        -- profile["mac-addr"] = device_details.macaddr
        profile["mode"] = section.mode
        profile["default"] = false
        -- if section.mld and section.mld ~= "" then
        --     profile["default"] =  true
        -- end
        -- Add the profile to the profiles table
        table.insert(profiles, profile)
    end)

    return profiles
end

local function get_sequence_time()
    local config = "ispapp"
    local section = "config"

    -- Get current sequenceNumber and increment it
    local sequenceNumber = tonumber(uci:get(config, section, "sequenceNumber") or "0")
    sequenceNumber = sequenceNumber + 1

    -- Get the current timestamp for lastConfigRequest (as a Unix timestamp)
    local lastConfigRequest = tonumber(sys.exec("date +%s"))

    -- Update UCI with new values
    uci:set(config, section, "sequenceNumber", tostring(sequenceNumber))
    uci:set(config, section, "lastConfigRequest", lastConfigRequest)

    -- Commit the changes to UCI
    uci:commit(config)

    -- Return the updated values
    return {
        lastConfigRequest = tonumber(lastConfigRequest),
        sequenceNumber = sequenceNumber
    }
end

local function is_using_websocket()
    local config = "ispapp"
    local section = "config"

    -- Retrieve the Domain value from the config
    local Domain = uci:get(config, section, "Domain")

    -- Check if Domain starts with ws:// or wss:// (for WebSocket and secure WebSocket)
    if Domain and (Domain:match("^ws://") or Domain:match("^wss://")) then
        return true
    else
        return false
    end
end

local function wirelessSupport()
    -- Try to find wireless interfaces using 'iw dev'
    local iw_output = sys.exec("iw dev")

    -- If 'iw dev' has output, then wireless interfaces exist
    if iw_output and iw_output ~= "" then
        return true
    end

    -- If 'iw dev' didn't return anything, try using 'ifconfig'
    local ifconfig_output = sys.exec("ifconfig -a")

    -- Look for typical wireless interface prefixes (e.g., wlan, wifi)
    local wireless_interfaces = {"wlan", "wifi", "ath", "ra"} -- Common wireless prefixes

    for _, prefix in ipairs(wireless_interfaces) do
        if ifconfig_output:match(prefix) then
            return true
        end
    end

    -- If no wireless interfaces found, return false
    return false
end

local function wirelessConfigured()
    local wireless_info = {}
    local band_map = {
        ["11-1997"] = "2.4ghz-dsss/fhss",
        ["11b"] = "2.4ghz-hr/dsss",
        ["11a"] = "5ghz-ofdm",
        ["11g"] = "2.4ghz-erp-ofdm",
        ["11n"] = "2.4/5ghz-ht-ofdm",
        ["11beg"] = "2.4ghz-ofdm",
        ["11ac"] = "5ghz-vht-ofdm",
        ["11ax"] = "2.4/5/6ghz-he-ofdma",
        ["11be"] = "2.4/5/6ghz-eht-ofdma",
        ["11ad"] = "60ghz-dmg",
        ["11ay"] = "60ghz-edmg",
        ["11ah"] = "sub-1ghz-s1g",
        ["11p"] = "5.9ghz-vehicular",
        ["11bd"] = "5.9/60ghz-vehicular",
        ["11ba"] = "2.4/5ghz-wur",
        ["11bn"] = "2.4/5/6/42/60/71ghz-uhr",
        ["11bea"] = "2.4/5/6ghz-eht-ofdma"
    }

    uci:foreach("wireless", "wifi-iface", function(section)
        local device = section.device
        local ssid = section.ssid or "N/A"
        local macaddr = uci:get("wireless", device, "macaddr") or "N/A"
        local disabled = section.disabled == "1"
        local running = sys.exec("iw dev " .. section.device .. " info 2>/dev/null"):match("Interface") ~= nil
        local band = uci:get("wireless", device, "hwmode") or "N/A"
        local interface_type = uci:get("wireless", device, "type") or "N/A"

        -- Translate the band (hwmode) into readable format
        -- Translate the band (hwmode) into readable format
        local band_readable = band_map[band] or "N/A"
        
        -- Try to get additional frequency information from iw dev command
        local iw_info = sys.exec("iw dev " .. section.device .. " info 2>/dev/null")
        local frequency = iw_info:match("channel%s+%d+%s+%((%d+)%s+MHz%)") or ""
        if frequency and frequency ~= "" then
            band_readable = band_readable .. " (" .. frequency .. " MHz)"
        end
        -- local band_readable = band_map[band] or "N/A"

        -- Build the object structure
        local _key = getKey(section['.name'])
        table.insert(wireless_info, {
            [".id"] = "*" .. tostring(section['.index']),
            band = band_readable,
            disabled = disabled,
            ["hide-ssid"] = section.hidden == "1",
            name = section['.name'] or "N/A",
            ["if"] = section['.name'] or "N/A",
            ["interface-type"] = interface_type,
            encryption = getEncryption(section['.name']),
            key = _key or "N/A",
            ["mac-address"] = macaddr,
            ["master-interface"] = device,
            running = running,
            ["security-profile"] = "*" .. tostring(section['.index']),
            ssid = ssid,
            technology = "wireless"
        })
    end)

    return wireless_info
end
-- get uptime in seconds
local function get_uptime()
    local uptime_str = sys.exec("cat /proc/uptime")
    local uptime_seconds, idle_time_seconds = uptime_str:match("^(%S+) (%S+)")
    return math.floor(tonumber(uptime_seconds) or 0), math.floor(tonumber(idle_time_seconds) or 0)
end

-- Function to get the WAN IP address
local function getWanIp()
    -- Run the command to fetch global IPv4 addresses
    local cmd = "ip -4 addr show | awk '/global/ && /inet/ {print $2}' | cut -d'/' -f1 | awk '{printf \"%s%s\", (NR>1?\",\":\"\"), $0}'"
    local handle, res, _ = pcall(util.exec, cmd)
    if not handle then
        return nil, "Unable to execute command"
    end
    return res and res:match("%d+%.%d+%.%d+%.%d+") or "N/A"
end
-- ip -4 addr show | awk '/global/' | awk '/inet/ {print $2}' | cut -d'/' -f1

-- Function to generate the CollectConfigs response
local function CollectConfigs()
    local seq_lasttmp = get_sequence_time()
    local cpucores, cpumodel = getCPUInfo()
    local ipinfo = getExternalIpInfo()
    local osrelease = parseOsRelease()
    local uptime, idle_time = get_uptime()
    local board_info = getBoardInfo()
    local response = {
        agent = "openwrt",
        bandwidthTestSupport = commandExists("iperf") or commandExists("iperf3") or commandExists("btest"),
        clientInfo = getReleaseValue("DISTRIB_ID") .. "-" .. getReleaseValue("DISTRIB_RELEASE"),
        firmwareUpgradeSupport = commandExists("fwupgrade-tools"),
        fw = getReleaseValue("DISTRIB_DESCRIPTION"),
        hardwareCpuInfo = cpumodel .. ", " .. cpucores .. " cores",
        hardwareMake = board_info.hardwareMake,
        hardwareModel = board_info.hardwareModel,
        hardwareModelNumber = board_info.hardwareModelNumber,
        hardwareSerialNumber = board_info.hardwareSerialNumber,
        hostname = sys.hostname(),
        interfaces = getNetworkInterfaces(),
        lastConfigRequest = seq_lasttmp.lastConfigRequest,
        os = osrelease.VERSION_ID,
        osBuildDate = fs.stat("/sys/class").mtime,
        osVersion = osrelease.VERSION,
        outsideIp = ipinfo.ip,
        asn = ipinfo.asn,
        wanIp = getWanIp(), -- this should be local ip
        Lng = tonumber(ipinfo.longitude),
        lat = tonumber(ipinfo.latitude),
        ["security-profiles"] = collectSecurityProfiles(),
        sequenceNumber = seq_lasttmp.sequenceNumber,
        uptime = uptime,
        usingWebSocket = is_using_websocket(),
        webshellSupport = true,
        wirelessConfigured = wirelessConfigured(),
        WirelessConfig = catFile("/etc/config/wireless"),
        wirelessSupport = wirelessSupport()
    }

    return response
end
local function getPing()
    local ping_data = {
        host = "1.1.1.1" -- default ping target
    }
    local pingtarget0 = uci:get("ispapp", "@settiongs[0]", "Domain")
    if pingtarget0 and pingtarget0 ~= "" then
        ping_data.host = pingtarget0
    end
    local pingtarget1 = uci:get("ispapp", "@settiongs[0]", "pingtarget")
    if pingtarget1 and pingtarget1 ~= "" then
        ping_data.host = pingtarget1
    end
    -- Check if the ping command is available
    local okcmd, pingcmd = pcall(util.exec, string.format([[
    ping -c 5 %s -q | tail -1 | awk -F' = ' '{split($2, arr, "/"); gsub(" ms", "", arr[1]); gsub(" ms", "", arr[2]); gsub(" ms", "", arr[3]); print "{\"min\": " arr[1] ", \"avg\": " arr[2] ", \"max\": " arr[3] "}"}'
    ]], ping_data.host))
    if not okcmd then
        return {
            host = ping_data.host,
            avgRtt = 0,
            minRtt = 0,
            maxRtt = 0,
            loss = 100
        }
    end
    local ok, ping = pcall(jsonc.parse, pingcmd)
    if not ok or not ping then
        return {
            host = ping_data.host,
            avgRtt = 0,
            minRtt = 0,
            maxRtt = 0,
            loss = 100
        }
    end
    ping_data = {
        host = ping_data.host,
        avgRtt = tonumber(ping.avg, 10),
        minRtt = tonumber(ping.min, 10),
        maxRtt = tonumber(ping.max, 10),
        loss = 0
    }
    return ping_data
end
-- Function to get interface statistics
local function get_interface_stats()
    local interfaces = {}
    -- ubus -v call iwinfo devices
    local devices = conn:call("network.device", "status", {})
    if devices then
        for name, iface_status in pairs(devices) do
            -- ubus -v call network.device status '{"name":"<name>"}'
            local stats = iface_status.statistics or {}
            local interf = {}
            interf["if"] = name
            interf["last_report_timestamp"] = os.time()
            interf["defaultIf"] = name
            interf["mac"] = iface_status.macaddr or "00:00:00:00:00:00"
            interf["recBytes"] = stats.rx_bytes or 0
            interf["recPackets"] = stats.rx_packets or 0
            interf["recErrors"] = stats.rx_errors or 0
            interf["recDrops"] = stats.rx_dropped or 0
            interf["up"] = iface_status.up or false
            interf["sentBytes"] = stats.tx_bytes or 0
            interf["sentPackets"] = stats.tx_packets or 0
            interf["sentErrors"] = stats.tx_errors or 0
            interf["sentDrops"] = stats.tx_dropped or 0
            interf["carrierChanges"] = tonumber(catFile("/sys/class/net/" .. name .. "/carrier_changes")) or 0
            interf["type"] = iface_status.type or "N/A"
            interf["bridge-members"] = iface_status["bridge-members"] or {}
            interf["macs"] = 0
            interf["foundDescriptor"] = "ubus parsed"
            local link_speed = tonumber(catFile("/sys/class/net/" .. name .. "/speed") or 0)
            link_speed = link_speed > 0 and link_speed or 0
            interf["link_speed"] = link_speed
            -- new added interfaces data 
            interf["negotiation_type"] = iface_status["autoneg"] and "auto" or "manual"
            interf["carrier"] = tonumber(iface_status.carrier) or 0
            interf["carrier_up_count"] = tonumber(catFile("/sys/class/net/" .. name .. "/carrier_up_count")) or 0
            interf["carrier_down_count"] = tonumber(catFile("/sys/class/net/" .. name .. "/carrier_down_count")) or 0
            interf["present"] = iface_status.present or false
            interf["external"] = iface_status.external or false
            interf["ipv6"] = iface_status.ipv6 or false
            interf["mtu"] = tonumber(catFile("/sys/class/net/" .. name .. "/mtu")) or 0
            interf["link-supported"] = iface_status["link-supported"] or {}
            interf["link-advertising"] = iface_status["link-advertising"] or {}
            interf["link-partner-advertising"] = iface_status["link-partner-advertising"] or {}
            interf["multicast"] = iface_status["multicast"] or false
            interf["ipv6"] = iface_status["ipv6"] or false
            table.insert(interfaces, interf)
        end
    else
        log_error("Failed to get interface statistics")
    end

    return interfaces
end
-- Function to get wireless devices using UCI
local function get_wireless_devices()
    local wireless_devices = {}
    uci:foreach("wireless", "wifi-iface", function(section)
        table.insert(wireless_devices, section.device)
        if section.mld_ssid then
            table.insert(wireless_devices, section.name)
        end
    end)
    return wireless_devices
end
-- parse the dhcp leases from the default location
local function getDhcpLeases()
    local leases = {}
    local file = io.open("/tmp/dhcp.leases", "r")
    if not file then
        return {}
    end
    for line in file:lines() do
        -- Match the five fields in lease file
        local timestamp, mac, ip, hostname, duid = line:match("(%d+)%s+([%x:]+)%s+([%d%.]+)%s+([^%s]+)%s+([^%s]+)")

        if timestamp then
            -- Convert timestamp to readable format
            local readable_time = os.date("%Y-%m-%d %H:%M:%S", tonumber(timestamp))

            -- Replace "*" with "Unknown" for hostname
            hostname = hostname == "*" and "Unknown" or hostname
            -- Replace "*" with MAC for DUID if missing
            duid = duid == "*" and mac or duid
            -- we chould make the mac address ad key in a map to find the leases faster
            leases[mac] = {
                timestamp = readable_time,
                mac = mac,
                ip = ip,
                hostname = hostname,
                duid = duid
            }
        end
    end
    if #leases == 0 then
        return nil
    end
    return leases
end

-- parse arp table into a table
local function getArpTable()
    -- Execute ARP command and capture output
    local handle = io.popen("cat /proc/net/arp")
    if handle == nil then
        return {
            devices = {}
        }
    end
    local result = handle:read("*a")
    handle:close()

    -- Initialize return table
    local arpTable = {
        devices = {}
    }

    -- Skip header line and process entries
    local firstLine = true
    for line in result:gmatch("[^\r\n]+") do
        if not firstLine then
            -- Parse each line into components
            local ip, hwtype, flags, mac, mask, device = line:match("(%S+)%s+(%S+)%s+(%S+)%s+(%S+)%s+(%S+)%s+(%S+)")

            -- Add to structured table
            if ip and mac and device then
                -- Create device entry if it doesn't exist
                if not arpTable.devices[device] then
                    arpTable.devices[device] = {
                        name = device,
                        clients = {}
                    }
                end

                -- Add client info
                table.insert(arpTable.devices[device].clients, {
                    ip = ip,
                    mac = mac,
                    flags = flags,
                    hwtype = hwtype,
                    mask = mask
                })
            end
        end
        firstLine = false
    end

    return arpTable
end

-- parse easymesh 
local function getEasyMesh()
    local topo = conn:call("device", "getRealTopo", {})
    if topo == nil then
        return {
            topo = {}
        }
    end
    return topo
end

local function ParseWlanConfigList(device)
    -- local output = {}
    local handle = io.popen("wlanconfig " .. device .. " list")
    if not handle then
        return {}
    end

    local content = handle:read("*a")
    handle:close()

    local current_client = nil
    local clients = {}

    for line in content:gmatch("[^\r\n]+") do
        -- New client entry starts with MAC address
        if line:match("^%x%x:%x%x:%x%x:%x%x:%x%x:%x%x") then
            -- Save previous client if exists
            if current_client then
                table.insert(clients, current_client)
            end

            -- Initialize new client with default values
            current_client = {
                addr = "",
                aid = 0,
                chan = 0,
                txrate = "0M",
                rxrate = "0M",
                rssi = 0,
                minrssi = 0,
                maxrssi = 0,
                idle = 0,
                txseq = 0,
                rxseq = 0,
                caps = "",
                xcaps = "",
                acaps = "",
                erp = 0,
                state = "",
                maxrate = "",
                htcaps = "",
                vhtcaps = "",
                assoctime = "",
                ies = "",
                mode = "",
                rxnss = 0,
                txnss = 0,
                psmode = 0,
                min_tx_power = 0,
                max_tx_power = 0,
                ht_capable = false,
                vht_capable = false,
                mu_capable = false,
                snr = 0,
                operating_band = "",
                operating_class = 0,
                supported_classes = {},
                supported_rates = {},
                max_sta_phymode = "",
                mlo = false
            }

            -- Parse client basic info
            local parts = {}
            for part in line:gmatch("%S+") do
                table.insert(parts, part)
            end

            current_client.addr = parts[1] or ""
            current_client.aid = tonumber(parts[2]) or 0
            current_client.chan = tonumber(parts[3]) or 0
            current_client.txrate = parts[4] or "0M"
            current_client.rxrate = parts[5] or "0M"
            current_client.rssi = tonumber(parts[6]) or 0
            current_client.minrssi = tonumber(parts[7]) or 0
            current_client.maxrssi = tonumber(parts[8]) or 0

            -- Parse additional info for current client
        elseif current_client then
            local min_tx = line:match("Minimum Tx Power%s*:%s*(%d+)")
            if min_tx then
                current_client.min_tx_power = tonumber(min_tx)
            end

            local max_tx = line:match("Maximum Tx Power%s*:%s*(%d+)")
            if max_tx then
                current_client.max_tx_power = tonumber(max_tx)
            end

            local snr = line:match("SNR%s*:%s*(%d+)")
            if snr then
                current_client.snr = tonumber(snr)
            end

            local band = line:match("Operating band%s*:%s*([%w]+)")
            if band then
                current_client.operating_band = band
            end

            local ht_cap = line:match("HT Capability%s*:%s*(%w+)")
            if ht_cap then
                current_client.ht_capable = (ht_cap == "Yes")
            end

            local vht_cap = line:match("VHT Capability%s*:%s*(%w+)")
            if vht_cap then
                current_client.vht_capable = (vht_cap == "Yes")
            end

            local mu_cap = line:match("MU capable%s*:%s*(%w+)")
            if mu_cap then
                current_client.mu_capable = (mu_cap == "Yes")
            end
        end
    end

    -- Add last client if exists
    if current_client then
        table.insert(clients, current_client)
    end

    return clients
end

-- Function to get the frequency from the channel
local function get_wifi_params(device)
    if not device or device == "" then
        return nil, "Device name is required"
    end

    local function run_command(cmd, is_mac)
        local handle = io.popen(cmd)
        if not handle then return nil, "Failed to execute command" end
        local result = handle:read("*a")
        handle:close()
        result = result and result:gsub("\n", ""):match(is_mac and "%S+" or "%-?%d+%.?%d*") or ""
        return result ~= "" and result or nil, result == "" and "No data found" or nil
    end

    local params = {}
    local errors = {}

    params.noise, errors.noise = run_command("awk '$1 ~ /" .. device .. "/ {print $5}' /proc/net/wireless")
    params.signal, errors.signal = run_command("awk '$1 ~ /" .. device .. "/ {print $3}' /proc/net/wireless")
    params.channel, errors.channel = run_command("iw dev " .. device .. " info | grep channel | awk '{print $2}'")
    params.frequency, errors.frequency = run_command("iw dev " .. device .. " info | grep channel | awk '{print $3}'")
    params.ssid, errors.txPower = run_command("iw dev " .. device .. " info | grep ssid | awk '{print $2}'", true)
    params.txPower, errors.txPower = run_command("iw dev " .. device .. " info | grep txpower | awk '{print $2}'")
    -- params.quality, errors.quality = run_command("iw dev " .. device .. " info | grep Quality | awk '{print $2}'")
    -- params.rate, errors.rate = run_command("iw dev " .. device .. " link | grep 'tx bitrate' | awk '{print $3}'")
    params.chutil, errors.chutil = run_command("iw dev " .. device .. " survey dump | grep " .. device .. " | grep channel | awk '{print $2}'")
    params.bandWidth, errors.bandWidth = run_command("iw dev " .. device .. " info | grep width | awk '{print $2}'")
    params.mac, errors.mac = run_command("cat /sys/class/net/" .. device .. "/address",true)
    params.mode, errors.mode = run_command("iw dev " .. device .. " info | grep type | awk '{print $2}'", true)
    params.phy, errors.phy = run_command("cat /sys/class/net/" .. device .. "/phy80211/name")

    -- Try to retrieve TXRATE and RSSI from wlanconfig
    local wlanconfig_cmd = "wlanconfig " .. device .. " list"
    local wlanconfig_output, _ = io.popen(wlanconfig_cmd)

    if wlanconfig_output then
        -- Split the wlanconfig output into lines
        local lines = {}
        for line in wlanconfig_output:lines() do
            table.insert(lines, line)
        end
        -- Check if there is at least two lines (the second line contains the relevant data)
        if #lines >= 2 then
            -- Match the first line to find the position of TXRATE and RSSI
            local txRate_pos = lines[1]:find("TXRATE")
            local rssi_pos = lines[1]:find("RSSI")
            local quality_pos = lines[1]:find("RXSEQ")

            -- Extract TXRATE and RSSI from the second line based on the found positions
            if txRate_pos and rssi_pos then
                -- Find the values of TXRATE and RSSI in the second line
                local txRate = lines[2]:sub(txRate_pos + 7, txRate_pos + 11):match("%S+")
                local rssi = lines[2]:sub(rssi_pos + 7):match("(-?%d+)")
                local quality = lines[2]:sub(quality_pos + 7):match("(-?%d+)")

                if txRate then
                    params.rate = txRate
                end
                if rssi then
                    params.signal = tonumber(rssi)
                end
                if quality then
                    params.quality = tonumber(quality)
                end
            end
        end
    end

    -- Fallback to iw dev if quality or rate is not available
    if not params.signal then
        params.signal, errors.signal = run_command("iw dev " .. device .. " station dump | grep 'signal' | awk '{print $2}'")
    end
    if not params.rate then
        params.rate, errors.rate = run_command("iw dev " .. device .. " station dump | grep 'tx bitrate' | awk '{print $3}'")
    end
    if not params.quality then
        params.quality, errors.quality = run_command("iw dev " .. device .. " station dump | grep 'signal avg' | awk '{print $3}'")
    end

    -- Ensure values are correctly formatted
    if params.noise then params.noise = tonumber(params.noise) end
    if params.signal then params.signal = tonumber(params.signal) end
    if params.channel then params.channel = tonumber(params.channel) end
    if params.frequency then params.frequency = tonumber(params.frequency) end
    if params.txPower then params.txPower = tonumber(params.txPower) end
    if params.quality then params.quality = tonumber(params.quality) end
    if params.rate then params.rate = tonumber(params.rate) end
    if params.chutil then params.chutil = tonumber(params.chutil) end
    if params.bandWidth then params.bandWidth = tonumber(params.bandWidth) end

    -- Error handling
    local valid_params = {}
    for key, value in pairs(params) do
        if value then
            valid_params[key] = value
        elseif errors[key] then
            return nil, "Error retrieving " .. key .. ": " .. errors[key]
        end
    end

    return valid_params, nil
end

-- function to collect clients
local function GetWap()
    local devices = conn:call('iwinfo', 'devices', {})
    if not devices or not devices.devices then
        devices = get_wireless_devices()
    else
        devices = devices.devices
    end
    nixio.nanosleep(1, 0)
    local wap = {}
    local clients = {}
    for _, device in ipairs(devices) do
        clients = {}
        local wap_device = conn:call('iwinfo', 'info', {
            device = device
        })
        local ok, _clients = pcall(ParseWlanConfigList, device)
        if ok and #_clients > 0 then
            local toSeconds = function(time)
                if not time then
                    return 0
                end
                local parts = {}
                for part in time:gmatch("%d+") do
                    table.insert(parts, part)
                end
                local seconds = 0
                if #parts == 1 then
                    seconds = tonumber(parts[1]) or 0
                elseif #parts == 2 then
                    seconds = tonumber(parts[1]) * 60 + tonumber(parts[2])
                elseif #parts == 3 then
                    seconds = tonumber(parts[1]) * 3600 + tonumber(parts[2]) * 60 + tonumber(parts[3])
                elseif #parts == 4 then
                    seconds = tonumber(parts[1]) * 86400 + tonumber(parts[2]) * 3600 + tonumber(parts[3]) * 60 +
                                  tonumber(parts[4])
                end
                return seconds
            end
            local ratetobytes = function(rate)
                local _rate = rate:lower()
                _rate = _rate:gsub("m", "000000")
                _rate = _rate:gsub("k", "000")
                _rate = _rate:gsub("g", "000000000")
                _rate = _rate:gsub("b", "")
                return tonumber(_rate)
            end
            local alreadyexist = {}
            for _, client in pairs(_clients) do
                if not alreadyexist[client.addr] then
                    local dhcps = getDhcpLeases()
                    table.insert(clients, {
                        mac = client.addr, -- MAC address
                        info = "Station " .. client.addr, -- Optional description
                        rssi = tonumber(client.rssi), -- Signal strength in dBm
                        recBytes = ratetobytes(client.rxrate), -- 648M
                        sentBytes = ratetobytes(client.txrate), -- 720M
                        ccq = ratetobytes(client.rxrate) / (ratetobytes(client.maxrate) or 1), -- CCQ (%)=(Actual Transmitted Data​/Maximum Possible Data)×100
                        noise = tonumber(client.snr) or 0, -- Noise level in dBm
                        signal0 = tonumber(client.minrssi) or -1,
                        signal1 = tonumber(client.rssi) or -1,
                        signal2 = tonumber(client.maxrssi) or -1,
                        dhcp = dhcps and dhcps[client.addr] or {
                            hostname = "N/A",
                            ip = "N/A",
                            mac = client.addr,
                            duid = "N/A"
                        }, -- add it to db model
                        signal3 = tonumber(client.rssi_combined) or -1,
                        -- add estimate_distance
                        expectedRate = ratetobytes(client["maxrate(dot11)"] or client["maxrate"] or "0"), -- 2882400
                        assocTime = toSeconds(client.assocTime) or 0, -- 08:48:36 or  23:08:48:36
                        beaconLoss = 0, -- Number of beacon losses (adjust if data exists)
                        foundDescriptor = "wlanconfig parsed"
                    })
                    alreadyexist[client.addr] = true
                end
            end
        end
        if wap_device then
            local avgsignal = function(signal, clients)
                if not signal then
                    return -1
                end
                local sum = 0
                if #clients == 0 then
                    return -1
                end
                for _, client in pairs(clients) do
                    sum = sum + tonumber(client[signal] or 0)
                end
                return sum / #clients
            end
            local params = get_wifi_params(device)
            if params == nil then
                params = {}
            end
            local foundDescriptor =  "wifi interface - " .. device .. " - " .. (params.chutil or "N/A")
            table.insert(wap, {
                interface = device,
                -- ssid = uci:get("wireless", device, "ssid") or wap_device.bssid or "N/A",
                ssid = params.ssid or wap_device.bssid or "N/A",
                stations = clients or {},
                -- signals should be Retrieveed from clients avg signals
                signal0 = avgsignal("signal0", clients) or wap_device.quality_max,
                signal1 = avgsignal("signal1", clients) or wap_device.quality_max,
                signal2 = avgsignal("signal2", clients) or wap_device.quality_max,
                signal3 = avgsignal("signal3", clients) or wap_device.quality_max,
                foundDescriptor = foundDescriptor,
                key = getKey(device), -- get it from uci
                keytypes = getEncryption(device), -- get it from uci
                -- new params from skynetdata with default values
                noise = params.noise or tonumber(wap_device.noise) or 0,
                signal = tonumber(params.signal or 0),
                channel = params.curChannel or 0,
                frequency = params.freq or 0,
                txPower = params.txPower or 0,
                quality = params.quality or 0,
                rate = params.rate or 0,
                chutil = params.chutil or 0,
                bandWidth = params.bandWidth or 0,
                mac = params.mac or "N/A",
                mode = params.mode or "N/A",
                phy = params.phy or "N/A"
            })
        end
    end
    return wap or {}
end
local function getSystemInfo()
    return {
        load = {
            one = tonumber(sys.exec("cat /proc/loadavg | awk '{print $1}'")), -- Load average for the last minute
            five = tonumber(sys.exec("cat /proc/loadavg | awk '{print $2}'")), -- Load average for the last 5 minutes
            fifteen = tonumber(sys.exec("cat /proc/loadavg | awk '{print $3}'")), -- Load average for the last 15 minutes
            processCount = tonumber(sys.exec("ps | wc -l"))
        },
        memory = {
            total = tonumber(sys.exec("cat /proc/meminfo | grep MemTotal | awk '{print $2}'")),
            free = tonumber(sys.exec("cat /proc/meminfo | grep MemFree | awk '{print $2}'")),
            buffers = tonumber(sys.exec("cat /proc/meminfo | grep Buffers | awk '{print $2}'")),
            cache = tonumber(sys.exec("cat /proc/meminfo | grep Cached | awk '{print $2}'"))
        },
        disks = {{
            mount = "/",
            used = tonumber(sys.exec("df / | grep / | awk '{print $3}'")),
            avail = tonumber(sys.exec("df / | grep / | awk '{print $4}'"))
        }}
    }
end
local function GetTcpInfo()
    local tcp = {
        uniqueIps = 0,          -- Number of unique IPs in the connection table
        syn = 0,                -- Number of SYN packets
        urg = 0,                -- Number of URG packets
        rst = 0,                -- Number of RST packets
        cwr = 0,                -- Number of CWR packets
        slowedPairPackets = 0   -- Number of packets with both CWR and ECE flags set
    }

    -- Function to count unique IPs from /proc/net/nf_conntrack
    local function countUniqueIps()
        local unique_ips = {}
        local conntrack_file = io.open("/proc/net/nf_conntrack", "r")
        if conntrack_file then
            for line in conntrack_file:lines() do
                if line:find("tcp") then
                    local src_ip = line:match("src=([%d%.]+)")
                    local dst_ip = line:match("dst=([%d%.]+)")
                    if src_ip then unique_ips[src_ip] = true end
                    if dst_ip then unique_ips[dst_ip] = true end
                end
            end
            conntrack_file:close()
        end
        return unique_ips
    end

    -- Function to parse /proc/net/netstat and extract TCP packet counts
    local function parseNetstat()
        local netstat_file = io.open("/proc/net/netstat", "r")
        if netstat_file then
            local headers, values
            for line in netstat_file:lines() do
                if line:find("^TcpExt:") then
                    if not headers then
                        headers = {}
                        for header in line:gmatch("(%S+)") do
                            table.insert(headers, header)
                        end
                    else
                        values = {}
                        for value in line:gmatch("(%d+)") do
                            table.insert(values, tonumber(value))
                        end
                        break
                    end
                end
            end
            netstat_file:close()

            if headers and values then
                local stats = {}
                for i = 2, #headers do
                    stats[headers[i]] = values[i]
                end
                return stats
            end
        end
        return nil
    end

    -- Count unique IPs
    local unique_ips = countUniqueIps()
    tcp.uniqueIps = 0
    for _ in pairs(unique_ips) do
        tcp.uniqueIps = tcp.uniqueIps + 1
    end

    -- Parse netstat for TCP packet counts
    local netstat_stats = parseNetstat()
    if netstat_stats then
        tcp.syn = netstat_stats.TCPSynRetrans or 0
        tcp.urg = netstat_stats.TCPUrgentPackets or 0
        tcp.rst = netstat_stats.TCPAbortOnData or 0
        tcp.cwr = netstat_stats.TCPCongestionRecovery or 0
        if tcp.cwr > 0 and (netstat_stats.TCPECESent or 0) > 0 then
            tcp.slowedPairPackets = tcp.slowedPairPackets + 1
        end
    end

    return tcp
end


-- Function to generate a unique identifier based on system properties
local function gather_unique_id()
    -- Function to get the MAC address using `ifconfig`
    local function get_mac_address()
        local mac_address = nil
        -- Run the `ifconfig` command and capture the output
        local ifconfig_output = sys.exec("/sbin/ifconfig -a")
        if not ifconfig_output then
            return "00:00:00:00:00:00"
        end
        -- Look for the MAC address in the output (adjust the pattern if needed)
        mac_address = ifconfig_output:match("HWaddr (%x%x:%x%x:%x%x:%x%x:%x%x:%x%x)")

        -- If no MAC address found, fall back to nil
        return mac_address or "00:00:00:00:00:00"
    end
    -- Gather necessary values
    local mac_address = get_mac_address() -- MAC address of the specified interface
    local cpucores = tonumber(sys.exec("cat /proc/cpuinfo | grep 'processor' | wc -l")) or 0 -- Number of CPU cores

    -- Get RAM size
    local ram_size = 0
    local ram_partitions = tonumber(sys.exec("cat /proc/partitions | grep ram | wc -l")) or 0
    if ram_partitions > 0 then
        ram_size = ram_partitions * 4096 -- Assuming each ram partition is 4096 blocks
    end

    -- Get MTD size and count
    local mtd_size = 0
    local mtd_partitions = tonumber(sys.exec("cat /proc/partitions | grep mtdblock | wc -l")) or 0
    if mtd_partitions > 0 then
        local mtd_data = sys.exec("cat /proc/partitions | grep mtdblock")
        for line in mtd_data:gmatch("[^\r\n]+") do
            local _, _, blocks = line:find("(%d+)%s+(%d+)%s+(%d+)%s+mtdblock%d")
            if blocks then
                mtd_size = mtd_size + tonumber(blocks)
            end
        end
    end

    -- Gather CPU specifications (e.g., BogoMIPS)
    local bogomips = sys.exec("cat /proc/cpuinfo | grep 'BogoMIPS' | head -n 1 | awk '{print $3}'") or "0"

    -- Number of ports can be gathered from network interfaces
    local num_ports = tonumber(sys.exec("ls /sys/class/net/ | grep 'eth' | wc -l")) or 0

    -- Combine all values into a string
    local unique_string = string.format("%s%d%d%d%s%d", mac_address, cpucores, ram_size, mtd_size, bogomips, num_ports)
    -- local md5_module, err = pcall(require, "md5c")
    -- Function to generate UUID format from the unique string
    local hash = md5.tohex(unique_string:gsub("[%.:\n]", "")) -- or use any hashing library available
    local res = string.format("%s-%s-4%s-%s-%s", hash:sub(1, 8), hash:sub(9, 12), hash:sub(13, 16), hash:sub(17, 20),
        hash:sub(21))

    return res
end
local function check_domain()
    local host = uci:get("ispapp", "@settings[0]", "Domain")
    local port = uci:get("ispapp", "@settings[0]", "ListenerPort")
    if not host then
        return {
            status = 404
        }
    end
    local uri = string.format('https://' .. host .. ':' .. port .. "/auth/uuid")
    local responce = getRequest(uri, 1)
    return {
        status = responce.code
    }
end
local function GetTokens(uri)
    local res = getRequest(uri, 1)
    if res.code == 200 then
        local tokens = jsonc.parse(res.body)
        uci:set("ispapp", "@settings[0]", "refreshToken", tokens.refreshToken)
        uci:set("ispapp", "@settings[0]", "accessToken", tokens.accessToken)
        uci:commit('ispapp')
        return jsonc.parse(res.body)
    else
        return {
            status = res.code,
            body = res.body
        }
    end
end

-- check token validity and refresh if needed
local function tokenrefrech()
    local host = uci:get("ispapp", "@settings[0]", "Domain")
    local port = uci:get("ispapp", "@settings[0]", "ListenerPort")
    local accessToken = uci:get("ispapp", "@settings[0]", "accessToken")
    local uri = string.format('https://' .. host .. ':' .. port .. '/auth/refresh' .. "?accessToken=" .. accessToken)
    local res = getRequest(uri, 1)
    if res.code == 200 then
        local tokens = jsonc.parse(res.body)
        uci:set("ispapp", "@settings[0]", "refreshToken", tokens.refreshToken)
        uci:set("ispapp", "@settings[0]", "accessToken", tokens.accessToken)
        uci:commit('ispapp')
        return res
    else
        log_info("Failed to refresh token" .. jsonc.stringify(res.body))
        return res
    end
end

local function host_signup()
    if not uci:get("ispapp", "@settings[0]") then
        return nil
    end
    local host = uci:get("ispapp", "@settings[0]", "Domain") or "prv.cloud.ispapp.co"
    local port = uci:get("ispapp", "@settings[0]", "ListenerPort") or "443"
    local key = uci:get("ispapp", "@settings[0]", "Key") or ""
    local uuid_req = string.format("https://%s:%s/auth/uuid", host, port)
    local login = ""
    local uci_login = uci:get("ispapp", "@settings[0]", "login")
    local env_login = sys.exec("fw_printenv | grep login | awk -F '=' '{print $2}'")
    local function set_login(_login)
        uci:set("ispapp", "@settings[0]", "login", _login)
        uci:commit("ispapp")
    end
    if uci_login and uci_login ~= "00000000-0000-0000-0000-000000000000" then
        login = uci_login
    elseif env_login and env_login == "00000000-0000-0000-0000-000000000000" then
        login = env_login
        set_login(uci_login)
    else
        local res_uuid = getRequest(uuid_req, 1)
        login = res_uuid.body or gather_unique_id()
        local ok, _, _ = pcall(util.exec, "fw_setenv login " .. login)
        if ok then
            local _, _, _ = pcall(util.exec, "fw_setenv key" .. key)
            local _, _, _ = pcall(util.exec, "fw_setenv prvdomain" .. host)
            log_info("\npersisting loin into the fw boot environment:" .. login .. "\n")
        end
        set_login(login)
    end
    local init_req = string.format('https://%s:%s/initconfig?login=%s&key=%s', host, port, login, key)
    local _config = CollectConfigs()
    local res = postRequest(init_req, _config, 1)
    local tokens = {}
    if res.code == 200 then
        log_info("Host added successfully")
        tokens = GetTokens(init_req)
    else
        log_error("Failed to add host")
    end
    return {
        status = res.status,
        code = res.code,
        tokens = tokens
    }
end

local function get_cpu_usage()
    -- Get the PID of the ispappd process
    local path = "/var/run/ispappd.pid"
    local pid = read_file(path)
    if not pid.result then
        log_error("Failed to read file " .. path .. "(ispappd is not running): " .. pid.error)
        return "(ispappd is not running)%"
    end

    local PID = pid.result:gsub("%D", "")
    local statm_file = string.format("pidstat -p %s | awk 'NR>3 {print $8}' | tr -d '\n'", PID)
    local ok, statm_content, err = pcall(sys.exec, statm_file)
    if ok then
        return statm_content .. "%"
    else
        return "N/A%"
    end
end
local function process_stats()
    -- Get the PID of the ispappd process
    local path = "/var/run/ispappd.pid"
    local pid = read_file(path)
    if not pid.result then
        log_error("Failed to read file " .. path .. "(ispappd is not running): " .. pid.error)
        return "(ispappd is not running)%"
    end

    local PID = pid.result:gsub("%D", "")
    local statm_file = string.format([[
    cat /proc/%s/status | awk '/VmRSS/ {vmrss=$2 " " $3} /Threads/ {threads=$2} /Cpus_allowed/ {cpus_allowed=$2} /State/ {state=$2$3} END {print "{\"VmRSS\":\"" vmrss "\",\"Threads\":" threads ",\"Cpus_allowed\":\"" cpus_allowed "\",\"State\":\"" state "\"}"}'
    ]], PID)
    -- getting used memory by bytes
    local ok, statm_content, err = pcall(sys.exec, statm_file)
    if not ok or err then
        return {
            VmRSS = "N/A",
            Threads = "N/A",
            Cpus_allowed = "N/A",
            State = "N/A"
        }

    else
        return statm_content
    end
end
local function check_service()
    local cmd = "/etc/init.d/ispapp status"
    local output = sys.exec(cmd)
    if output == nil then
        log_error("Failed to execute command: " .. cmd)
        return "N/A"
    end
    return output
end

local function AddCollectorsToConfig()
    local ping = getPing()
    local wap = GetWap()
    local interface = get_interface_stats()
    local system = getSystemInfo()
    local tcp = GetTcpInfo()
    -- local scanned = false
    -- local wifi_area_scanning = {}
    -- local scanningerr = nil
    -- local lastTimeScanned = uci:get("ispapp", "@settings[0]", "lastTimeScanned")
    -- if not lastTimeScanned then
    --     uci:set("ispapp", "@settings[0]", "lastTimeScanned", os.time())
    --     uci:commit("ispapp")
    --     scanned, wifi_area_scanning, scanningerr = pcall(GetwifiScan)
    -- else
    --     -- compare in secconds and make sure it almost 10 minutes ago or more
    --     local diff = os.time() - lastTimeScanned
    --     if diff > 300 then
    --         scanned, wifi_area_scanning, scanningerr = pcall(GetwifiScan)
    --         if scanned then
    --             uci:set("ispapp", "@settings[0]", "lastTimeScanned", os.time())
    --             uci:commit("ispapp")
    --         end
    --     end
    -- end
    -- location = {
    --     lat = location.latitude,
    --     lng = location.longitude
    -- }
    local configs = CollectConfigs()
    local pings = {}
    pings[1] = ping
    configs["collectors"] = {
        ping = pings,
        wap = wap,
        interface = interface,
        system = system,
        tcp = tcp,
        -- location = location,
        arptable = getArpTable().devices,
        leases = getDhcpLeases(),
        topos = getEasyMesh().topo,
        -- wifi_area_scanning = {},
        spectralscan = {}
    }
    local spectral = get_spectral_data(100)
    -- if scanned then
    --     configs["collectors"].wifi_area_scanning = wifi_area_scanning
    -- end
    if spectral.ok then
        configs["collectors"].spectralscan = spectral.result
    end
    return configs
end

local function syncConfigs()
    local configs = AddCollectorsToConfig()
    print("configs collected")
    local host = uci:get("ispapp", "@settings[0]", "Domain")
    if not host then
        log_error("Failed to get server domain")
        return {
            status = 404
        }
    end
    local port = uci:get("ispapp", "@settings[0]", "ListenerPort") or "443"
    local login = uci:get("ispapp", "@settings[0]", "login")
    if not login then
        log_error("Failed to get login")
        return {
            status = 404
        }
    end
    local init_req = string.format('https://%s:%s/config', host, port, login)
    local res = postRequest(init_req, configs, 1)
    if res.code == 200 then
        log_info("Configs synced successfully")
    else
        log_error("Failed to sync configs")
    end
    return {
        status = res.status,
        body = res.body,
        code = res.code,
        init_req = init_req,
        configs = configs
    }
end
local function speedtest()
    -- speedtest command and send response as post to /bandwidth
    -- we take the iperf server from /www/luci-statis/resources/iperf.json
    local iperf_servers = {}
    local iperf_file = "/www/luci-static/resources/iperf"
    local loadedfile = read_file(iperf_file)
    if iperf_servers.error then
        log_error("Failed to read file " .. iperf_file .. ": " .. iperf_servers.error)
        return {
            status = false
        }
    end
    iperf_servers = jsonc.parse(loadedfile.result)
    local country = getExternalIpInfo().country and getExternalIpInfo().country:upper() or "US"
    local iperf = function()
        if commandExists("iperf3") then
            return "iperf3"
        end
        if commandExists("iperf") then
            return "iperf"
        end
        return nil
    end
    local _server = {}
    local time = os.time()
    local _iperf = iperf()
    if _iperf == nil then
        log_error("Failed to get iperf command")
        return {
            status = false
        }
    end
    local version = {
        V3 = commandExists("iperf3"),
        V2 = commandExists("iperf")
    }
    local _iperf_servers = {}
    for _, srv in pairs(iperf_servers) do
        if (version.V3 and srv.V3 == version.V3) or (version.V2 and srv.V2 == version.V2) then
            table.insert(_iperf_servers, srv)
        end
    end
    for _, server in ipairs(_iperf_servers) do
        if server.COUNTRY == country then
            _server = server
        end
    end
    local user_select = uci:get("ispapp", "@settings[0]", "IperfServer")
    if user_select then
        _server.IP_HOST = user_select
    end
    if not _server.IP_HOST then
        _server = iperf_servers[math.random(#_iperf_servers or 20)]
    end
    local cmd = ""
    if _server.V2 and version.V2 then
        cmd = string.format([[
                        %s -c %s -i 1 -t 1 -P 5 -f m | awk '/SUM/ {if (down == "") down=$7; else up=$7} END {printf "{ \"down\": %.2f, \"up\": %.2f }\n", down, up}'
                        ]], 'iperf', _server.IP_HOST)
    end
    if _server.V3 and version.V3 then
        cmd = string.format([[
                    %s -c %s  -i 1 -t 1 -P 5 -f m | awk '/SUM.*sender/ {up=$6} /SUM.*receiver/ {down=$6} END {print "{ \"down\": " down ", \"up\": " up " }"}'
                    ]], 'iperf3', _server.IP_HOST)
    end
    local ok, res, err = pcall(util.exec, cmd)
    if _iperf == 'iperf3' and not ok then
        log_error("[ispapp] Failed to execute command: " .. cmd .. " - " .. err)
        return {
            status = false
        }
    end
    local _time = os.time()
    local duration = os.difftime(_time, time)
    -- parse the result
    local jsonres = (function()
        if type(res) ~= "table" then
            return jsonc.parse(res)
        else
            return res
        end
    end)()
    local bandwidth = {
        date = os.date("%Y-%m-%d", _time),
        time = os.date("%H:%M:%S", _time),
        txAvg = 0,
        rxAvg = 0,
        rxDuration = string.format(duration .. 's'),
        txDuration = string.format(duration .. 's'),
        server = _server.IP_HOST
    }
    if jsonres and jsonres.up then
        bandwidth.txAvg = math.floor((tonumber(jsonres.up) or 0) * 1024)
        bandwidth.rxAvg = math.floor((tonumber(jsonres.down) or 0) * 1024)
    elseif jsonres and _iperf == "iperf3" then
        bandwidth.txAvg = math.floor(jsonres["end"].sum_sent and jsonres["end"].sum_sent.bits_per_second or 0)
        bandwidth.rxAvg = math.floor(jsonres["end"].sum_received and jsonres["end"].sum_received.bits_per_second or 0)
    end
    local host = uci:get("ispapp", "@settings[0]", "Domain")
    if not host then
        log_error("Failed to get server domain")
        return {
            bandwidth = bandwidth,
            status = false
        }
    end
    local port = uci:get("ispapp", "@settings[0]", "ListenerPort") or "443"
    local login = uci:get("ispapp", "@settings[0]", "login")
    if not login then
        log_error("Failed to get login")
        return {
            bandwidth = bandwidth,
            status = false
        }
    end
    local init_req = string.format('https://%s:%s/bandwidth', host, port)
    local responce = postRequest(init_req, bandwidth, 1)
    if responce.code == 200 then
        if responce.body then
            log_info("Bandwidth sent successfully: " .. responce.body)
            local new_IprefServer = jsonc.parse(responce.body)
            if new_IprefServer and new_IprefServer.setserver then
                uci:set("ispapp", "@settings[0]", "IperfServer", new_IprefServer.setserver)
                uci:commit("ispapp")
            end
        end
        log_info("Bandwidth sent successfully")
    else
        log_error("Failed to send bandwidth")
    end
    if bandwidth.txAvg == 0 and bandwidth.rxAvg == 0 then
        uci:set("ispapp", "@settings[0]", "IperfServer", iperf_servers[math.random(#_iperf_servers)])
    end
    return {
        bandwidth = bandwidth,
        responce = jsonc.parse(responce.body),
        status = responce.code
    }
end
local execActions = function(action)
    local actions = {
        executeSpeedtest = function()
            -- make routines 
            coroutine.wrap(speedtest)()
        end,
        upgrade = function()
            coroutine.wrap(sync_agent_version)()
            sys.reboot()
        end,
        reboot = function()
            sys.reboot()
        end
    }
    if actions[action] then
        actions[action]()
    end
end

local function update()
    local host = uci:get("ispapp", "@settings[0]", "Domain")
    if not host then
        log_error("Failed to get server domain")
        return {
            status = 404
        }
    end
    local port = uci:get("ispapp", "@settings[0]", "ListenerPort") or "443"
    local login = uci:get("ispapp", "@settings[0]", "login")
    if not login then
        log_error("Failed to get login")
        return {
            status = 404
        }
    end
    local init_req = string.format('https://%s:%s/update', host, port, login)
    local res = getRequest(init_req, 1, true)
    if res.code == 200 then
        log_info("update sent successfully")
        local responce = jsonc.parse(res.body)
        if #responce > 0 then
            -- if responce.cmds then
            --     -- submitCmds(responce.cmds)
            --     -- delay(#responce.cmds .. "s")
            --     -- executeCmds()
            -- end
            if responce.executeSpeedtest then
                execActions("executeSpeedtest")
            end
            if responce.fwStatus == "upgrade" then
                execActions("upgrade")
            end
            if responce.updateFast then
                -- update fast
                uci:set("ispapp", "@settings[0]", "updateInterval", "5")
                uci:commit("ispapp")
            end
            if responce.reboot == "1" then
                execActions("reboot")
            end
        end
    else
        log_error("Failed to sync updates")
    end
    return {
        status = res.status,
        body = res.body,
        code = res.code
    }
end
local function sendupdate()
    local host = uci:get("ispapp", "@settings[0]", "Domain")
    if not host then
        log_error("Failed to get server domain")
        return {
            code = 404
        }
    end
    local port = uci:get("ispapp", "@settings[0]", "ListenerPort") or "443"
    local login = uci:get("ispapp", "@settings[0]", "login")
    if not login then
        log_error("Failed to get login")
        return {
            code = 404
        }
    end
    local init_req = string.format('https://%s:%s/update', host, port, login)
    local updates = AddCollectorsToConfig()
    local _responce = postRequest(init_req, updates, 3)
    if _responce.code == 200 then
        log_info("Configs synced successfully")
    else
        log_error("Failed to sync updates")
    end
    return {
        status = _responce.status,
        body = _responce.body,
        code = _responce.code
    }
end
local function terminalHandler()
    local host = uci:get("ispapp", "@settings[0]", "Domain")
    if not host then
        log_error("Failed to get server domain")
        return {
            code = 404
        }
    end
    local port = uci:get("ispapp", "@settings[0]", "ListenerPort") or "443"
    local termReq = string.format('https://%s:%s/terminal', host, port)
    local _responce = {}
    local responce = postRequest(termReq, {}, 1)
    if responce.code == 200 then
        local termRes = jsonc.parse(responce.body)
        if termRes and termRes.queue then
            local finalcmds = {}
            for _, cmd in ipairs(termRes.queue) do
                local _, cmdRes, error = pcall(sys.exec, cmd.cmd)
                local res = cmd
                res.timestamp = os.time()
                res.stdout = cmdRes
                res.stderr = error
                res.executed = true
                table.insert(finalcmds, res)
            end
            _responce = postRequest(termReq, finalcmds, 1)
            if _responce.code == 200 then
                log_info("Command executed successfully: " .. _responce.body)
            else
                log_error("Failed to execute command: " .. _responce.body)
            end
        end
        log_info("Terminal opened successfully")
    else
        log_error("Failed to open terminal")
    end
    return {
        code = responce.code,
        status = responce.status,
        body = responce.body,
        sent = _responce
    }
end

local CleanUp = function()
    -- Get the PID of the ispappd process
    local path = "/var/run/ispappd.pid"
    local pid = read_file(path)
    -- no exclude_pid
    if pid and pid.result then
        -- running with exclude_pid
        local PID = pid.result:gsub("%D", "")
        sys.exec(string.format([[
         ps | grep '[i]spappd' | awk -v exclude_pid=%d '$1 != exclude_pid {print $1}' | xargs kill -9
    ]], PID))
    else
        sys.exec(string.format([[
        ps | grep '[i]spappd' | awk '{print $1}' | xargs kill -9
   ]]))
    end
end
local methods = {
    get_wap = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({
                wap = GetWap()
            })
            return r
        end
    },
    gps_module_info = {
        call = function()
            local r = {}
            local ok, responce, _ = pcall(util.exec, [[
                cat /tmp/gps_info.txt | tail -n 1 | awk -F', ' '{printf "{"; for (i = 1; i <= NF; i++) {split($i, a, "="); printf "\"%s\":\"%s\"", a[1], a[2]; if (i < NF) printf ", "} printf "}"}'
            ]]);
            if not ok then
                r.result = jsonc.stringify({
                    latitude = "N/A",
                    longitude = "N/A",
                    altitude = "N/A"
                })
            else
                r.result = jsonc.stringify(responce)
            end
            return r
        end
    },
    signup = {
        call = function()
            local ok, res, err = pcall(host_signup)
            return {
                result = jsonc.stringify({
                    status = ok,
                    error = err,
                    res = res
                })
            }
        end
    },
    config = {
        call = function()
            local ok, res, err = pcall(syncConfigs)
            local r = {}
            r.result = jsonc.stringify({
                status = ok,
                error = err,
                res = res
            })
            return r
        end
    },
    terminal = {
        call = function()
            local r = {}
            r.result = jsonc.stringify(terminalHandler())
            return r
        end
    },
    wifiscan = {
        args = {
            device = "string"
        },
        call = function(args)
            local r = {}
            r.result = jsonc.stringify(parse_bss_scan(args.device))
            return r
        end
    },
    wifimonitor = {
        call = function()
            local r = {}
            local ok, res, err = pcall(GetwifiScan)
            r.result = jsonc.stringify({
                error = err,
                ok = ok,
                responce = res
            })
            return r
        end
    },
    sendupdate = {
        call = function()
            local r = {}
            r.result = jsonc.stringify(sendupdate())
            return r
        end
    },
    cleanup = {
        call = function()
            local ok, res, err = pcall(CleanUp)
            return {
                result = jsonc.stringify({
                    status = ok,
                    error = err,
                    res = res
                })
            }
        end
    },
    update = {
        call = function()
            local r = {}
            r.result = jsonc.stringify(update())
            return r
        end
    },
    checkconnection = {
        call = function()
            local r = {}
            r.result = jsonc.stringify(tokenrefrech())
            return r
        end
    },
    get_config = {
        call = function()
            local r = {}
            local configs = CollectConfigs()
            r.result = jsonc.stringify(configs)
            return r
        end
    },
    get_update = {
        call = function()
            local r = {}
            local collected = AddCollectorsToConfig()
            r.result = jsonc.stringify(collected)
            return r
        end
    },
    get_cpu_usage = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({
                cpu_usage = get_cpu_usage()
            })
            return r
        end
    },
    process_stats = {
        call = function()
            local r = {}
            r.result = process_stats()
            return r
        end
    },
    read_ispapp_config = {
        call = function()
            return get_config()
        end
    },
    write_ispapp_config = {
        args = {
            config = "table"
        },
        call = function(args)
            return set_config(args.config)
        end
    },
    check_ispapp_status = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({
                status = check_service()
            })
            return r
        end
    },
    speedtest = {
        call = function()
            local r = {}
            local ok, res, err = pcall(speedtest)
            r.result = jsonc.stringify({
                status = ok,
                error = err,
                res = res
            })
            return r
        end
    },
    stop_ispapp = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({
                status = manage_service("stop")
            })
            return r
        end
    },
    start_ispapp = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({
                status = manage_service("start")
            })
            return r
        end
    },
    suspend_ispapp = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({
                status = manage_service("suspend")
            })
            return r
        end
    },
    sync_agent_version = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({
                status = sync_agent_version()
            })
            return r
        end
    },
    restart_ispapp = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({
                status = manage_service("restart")
            })
            return r
        end
    },
    query_ispapp = {
        call = query_service
    },
    read_pid_file = {
        call = function()
            return read_file("/var/run/ispapp.pid")
        end
    },
    check_domain = {
        call = function()
            local r = {}
            r.result = jsonc.stringify(check_domain())
            return r
        end
    },
    read_runtime_file = {
        call = function()
            return read_file("/tmp/ispapp_runtime.json")
        end
    },
    getdhcp_leases = {
        call = function()
            local r = {}
            r.result = jsonc.stringify(getDhcpLeases())
            return r
        end
    },
    getstations = {
        args = {
            device = "string"
        },
        call = function(args)
            local r = {}
            r.result = jsonc.stringify(ParseWlanConfigList(args.device))
            return r
        end
    },
    verify_config = {
        call = function()
            return jsonc.stringify(verify_config())
        end
    },
    read_crontab = {
        call = function()
            return read_file("/etc/crontabs/root")
        end
    },
    get_last_edit_time = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({
                last_edit_time = get_last_edit_time()
            })
            return r
        end
    },
    reload_envirement = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({
                status = reload_envirement()
            })
            return r
        end
    },
    save_to_envirement = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({
                status = save_to_envirement()
            })
            return r
        end
    },
    get_interfaces = {
        call = function()
            local r = {}
            r.result = jsonc.stringify(getNetworkInterfaces())
            return r
        end
    },
    get_active_time = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({
                active_time = get_active_time()
            })
            return r
        end
    },
    get_spectral_scan = {
        call = function(args)
            local r = {}
            local inter = args.interface or "wifi0"
            local ok, _, _err = pcall(util.exec, string.format("spectraltool -i %s get_samples 500 -x 1 -l ','", inter))
            local parsed, json, err = pcall(parse_spectral_data, "./outFile")
            r.result = jsonc.stringify({
                status = ok,
                parsed = parsed,
                error = _err,
                parseerror = err,
                json = json
            })
            return r
        end
    },
    get_interface_stats = {
        call = function()
            local r = {}
            r.result = jsonc.stringify(get_interface_stats())
            return r
        end
    },
    get_process_info = {
        args = {
            pid = "a_number"
        },
        call = function(args)
            local r = {}
            r.result = jsonc.stringify({
                cpu_usage = get_process_info(args.pid)
            })
            return r
        end
    },
    get_tcp_info = {
        call = function()
            local r = {}
            r.result = jsonc.stringify(GetTcpInfo())
            return r
        end
    },
    get_board_info = {
        call = function()
            local r = {}
            r.result = jsonc.stringify(getBoardInfo())
            return r
        end
    },
    get_ping = {
        call = function()
            local r = {}
            r.result = jsonc.stringify(getPing())
            return r
        end
    },
    get_wan_ip = {
        call = function()
            local r = {}
            local ok, res, error = pcall(getWanIp)
            if ok then
                r.result = jsonc.stringify({
                    wan_ip = res
                })
            else
                r.result = jsonc.stringify({
                    wan_ip = "N/A",
                    error = error
                })
            end
            return r
        end
    },
    get_device_mode = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({
                device_mode = get_device_mode()
            })
            return r
        end
    }
}

local function parseInput()
    local function read_with_timeout(timeout)
        local start_time = os.time()
        local input = ""
        while os.time() - start_time < timeout do
            local chunk = arg[3]
            if not chunk then
                break
            end
            input = input .. chunk
        end
        return input
    end

    local input = read_with_timeout(.01)
    local args = jsonc.parse(input)
    if not args then
        return {}
    end
    return args
end

local function validateArgs(func, uargs)
    -- Validates that arguments picked out by parseInput actually match
    -- up to the arguments expected by the function being called.
    local method = methods[func]
    if not method then
        print(jsonc.stringify({
            error = "Method not found in methods table"
        }))
        os.exit(1)
    end

    -- Lua has no length operator for tables, so iterate to get the count
    -- of the keys.
    local n = 0
    for _, _ in pairs(uargs) do
        n = n + 1
    end

    -- If the method defines an args table (so empty tables are not allowed),
    -- and there were no args, then give a useful error message about that.
    if method.args and n == 0 then
        print(jsonc.stringify({
            error = "Received empty arguments for " .. func .. " but it requires " .. jsonc.stringify(method.args)
        }))
        os.exit(1)
    end

    uargs.ubus_rpc_session = nil

    local margs = method.args or {}
    for k, v in pairs(uargs) do
        if margs[k] == nil or (v ~= nil and type(v) ~= type(margs[k])) then
            print(jsonc.stringify({
                error = "Invalid argument '" .. k .. "' for " .. func .. " it requires " .. jsonc.stringify(method.args)
            }))
            os.exit(1)
        end
    end

    return method
end

if arg[1] == "list" then
    local _, rv = nil, {}
    for _, method in pairs(methods) do
        rv[_] = method.args or {}
    end
    print((jsonc.stringify(rv):gsub(":%[%]", ":{}")))
elseif arg[1] == "call" then
    local args = parseInput()
    local method = validateArgs(arg[2], args)
    local run = method.call(args)
    print(run.result)
    os.exit(run.code or 0)
elseif arg[1] == "help" then
    local helptext = [[
Usage:

 To see what methods are exported by this script:
    ubus call ispapp list

 To call this script via ubus:
    ubus call ispapp method_name '{"valid": "json", "argument": "value"}'
]]
    print(helptext)
end