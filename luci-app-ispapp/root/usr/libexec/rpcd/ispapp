#!/usr/bin/env lua

-- ispapp ubus api
-- path: /usr/libexec/rpcd/ispapp
local jsonc = require "luci.jsonc"
local nixio = require "nixio"
local fs = require "nixio.fs"
local UCI = require "luci.model.uci"
local util = require "luci.util"
local sys = require "luci.sys"
local ubus = require "ubus"
local md5 = require "md5c"
local https = require("ssl.https")
local ltn12 = require("ltn12")
local http = require "socket.http"

local conn = ubus.connect()
if not conn then error("Failed to connect to ubus") end
local uci = UCI.cursor()
local function log_to_syslog(level, message) nixio.syslog(level, message) end
-- priority Priority ["emerg", "alert", "crit", "err", "warning", "notice", "info", "debug"] 
local function log_error(message)
    log_to_syslog("err", "[luci.ispapp]: " .. message)
end
local function log_info(message)
    log_to_syslog("info", "[luci.ispapp]: " .. message)
end
local function log_warning(message)
    log_to_syslog("info", "[luci.ispapp]: " .. message)
end
local function log_notice(message)
    log_to_syslog("info", "[luci.ispapp]: " .. message)
end

-- Function to make an HTTP request and ignore SSL verification
local function getRequest(url, timeout)
    local string_sub = string.sub
    local table_concat = table.concat
    http.TIMEOUT = timeout or 5
    http.USERAGENT =
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.97 Safari/537.36"
    local b, c, h, s
    local tbody = {}
    local https_opt = {
        url = url,
        protocol = "tlsv1_2",
        verify = "none",
        headers = {
            ["Accept"] = "*/*",
            ["Accept-Language"] = "sk;q=0.8,en-US,en;q=0.6,cs;q=0.4",
            ["Accept-Charset"] = "UTF-8;q=0.8,*;q=0.7"
        },
        sink = ltn12.sink.table(tbody),
        redirect = false
    }
    local http_opt = {
        url = url,
        headers = {
            ["Accept"] = "*/*",
            ["Accept-Language"] = "sk;q=0.8,en-US,en;q=0.6,cs;q=0.4",
            ["Accept-Charset"] = "UTF-8;q=0.8,*;q=0.7"
        },
        sink = ltn12.sink.table(tbody),
        redirect = false
    }
    if string_sub(url, 1, 5) ~= "https" then
        _, c, h, s = http.request(http_opt)
    else
        _, c, h, s = https.request(https_opt)
    end
    -- make headers keys lowercase
    if h ~= nil then
        local h_tmp = {}
        for k, v in pairs(h) do h_tmp[k:lower()] = v end
        h = h_tmp
    end
    -- concat body parts
    b = table_concat(tbody)
    return {body = b, code = c, headers = h, status = s}
end
-- Function to make a POST request with optional JSON body, authorization, and parameters
local function postRequest(url, data, timeout)
    local string_sub = string.sub
    local table_concat = table.concat
    local request_body = data and jsonc.stringify(data) or ""
    http.TIMEOUT = timeout or 5
    http.USERAGENT =
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.97 Safari/537.36"
    local b, c, h, s
    local tbody = {}
    local headers = {
        ["Accept"] = "*/*",
        ["Accept-Language"] = "sk;q=0.8,en-US,en;q=0.6,cs;q=0.4",
        ["Accept-Charset"] = "UTF-8;q=0.8,*;q=0.7",
        ["Content-Type"] = "application/json",
        ["Content-Length"] = #request_body
    }
    -- headers for access
    local accessToken = uci:get("ispapp", "@settings[0]", "accessToken")
    if accessToken and accessToken ~= "" then
        headers["Authorization"] = 'Bearer ' .. accessToken
    end
    local https_opt = {
        url = url,
        protocol = "tlsv1_2",
        verify = "none",
        method = "POST",
        source = ltn12.source.string(request_body),
        headers = headers,
        sink = ltn12.sink.table(tbody),
        redirect = false
    }
    local http_opt = {
        url = url,
        method = "POST",
        source = ltn12.source.string(request_body),
        headers = headers,
        sink = ltn12.sink.table(tbody),
        redirect = false
    }
    if string_sub(url, 1, 5) ~= "https" then
        _, c, h, s = http.request(http_opt)
    else
        _, c, h, s = https.request(https_opt)
    end
    -- make headers keys lowercase
    if h ~= nil then
        local h_tmp = {}
        for k, v in pairs(h) do h_tmp[k:lower()] = v end
        h = h_tmp
    end
    -- concat body parts
    b = table_concat(tbody)
    return {body = b, code = c, headers = h, status = s}
end

-- check for reponce initconfig status
local function CheckHostIsAdded(input)
    -- Check for "not added" or "host added" in the input (case insensitive)
    if not input then return false end
    if string.match(input:lower(), "not added") or
        string.match(input:lower(), "host added") then
        return false
    else
        return true
    end
end

local function read_file(path)
    local file, err = fs.readfile(path)
    if not file then
        log_error("Failed to read file " .. path .. ": " .. err)
        return {error = "Failed to read file."}
    end
    return {result = file, error = err}
end

local function exec_command(cmd)
    local ok, _, _ = pcall(util.exec, cmd)
    return {result = ok}
end

local function manage_service(action)
    local cmd = "/etc/init.d/ispapp " .. action
    return exec_command(cmd)
end

local function query_service()
    local cmd = "/etc/init.d/ispapp query *"
    return exec_command(cmd)
end

local function get_last_edit_time()
    local stat = fs.stat("/etc/config/ispapp")
    if stat and stat.mtime then
        return os.date("%Y-%m-%d %H:%M:%S", tonumber(stat.mtime))
    end
    return "N/A"
end

local function get_active_time()
    local datetime = sys.exec("date +'%Y-%m-%d %H:%M:%S'"):gsub("\n", "") -- Execute the command
    return datetime or "N/A" -- Return the result or "N/A" if the command fails
end

local function set_config(data)

    -- Apply configuration changes to '@settings[0]' section
    uci:set("ispapp", "@settings[0]", "enabled", data.enabled or '')
    uci:set("ispapp", "@settings[0]", "login", data.login or '')
    uci:set("ispapp", "@settings[0]", "Domain", data.Domain or '')
    uci:set("ispapp", "@settings[0]", "ListenerPort", data.ListenerPort or '')
    uci:set("ispapp", "@settings[0]", "SmtpPort", data.SmtpPort or '')
    uci:set("ispapp", "@settings[0]", "Key", data.Key or '')
    uci:set("ispapp", "@settings[0]", "ipbandswtestserver",
            data.ipbandswtestserver or '')
    uci:set("ispapp", "@settings[0]", "btuser", data.btuser or '')
    uci:set("ispapp", "@settings[0]", "btpwd", data.btpwd or '')

    local success, err = uci:commit("ispapp")
    if not success then
        log_error("Failed to commit changes to /etc/config/ispapp: " .. err)
        return {error = "Failed to save configuration."}
    end

    return {result = "Configuration saved successfully."}
end
-- verify config and make sure it's exist and filled with defaults if necessary
local function verify_config()
    local config = "ispapp"
    local section = "@settings[0]"

    -- Check if the ispapp config file and section exists
    if not uci:get(config, section) then
        -- Create the 'config' section with default options if it doesn't exist
        set_config({
            enabled = '0',
            login = '00000000-0000-0000-0000-000000000000',
            Domain = 'localhost',
            ListenerPort = '443',
            SmtpPort = '8465',
            Key = '',
            accessToken = '',
            refreshToken = '',
            connected = '0',
            ipbandswtestserver = '3.239.254.95',
            btuser = 'btest',
            btpwd = '0XSYIGkRlP6MUQJMZMdrogi2'
        })
        -- Commit the changes after creating the config
        uci:commit(config)
        return {result = "Configuration created successfully."}
    end
    return {result = "Configuration already exists."}
end
-- run verify_configs function to make sure all ok
-- verify_config()

-- local sys = require("luci.sys") -- Make sure to import sys

-- Function to get formatted process info by PID
local function get_process_info(pid)
    -- Read /proc/[pid]/statm for memory information
    local statm_file = string.format(
                           "pidstat -p %s | awk 'NR>3 {print $8}' | tr -d '\n'",
                           pid)
    local ok, statm_content = pcall(sys.exec, statm_file)
    if ok then
        return {result = statm_content}
    else
        return {error = "N/A%"}
    end
end

local function get_device_mode()
    local mode_count = {}

    -- Iterate over all wireless interfaces
    uci:foreach("wireless", "wifi-iface", function(section)
        if section.mode then
            local mode = section.mode
            -- Count occurrences of each mode
            mode_count[mode] = (mode_count[mode] or 0) + 1
        end
    end)
    -- Determine the majority mode
    local majority_mode, max_count = nil, 0
    for mode, count in pairs(mode_count) do
        if count > max_count then
            majority_mode = mode
            max_count = count
        end
    end

    -- Return the majority mode or a default value if none found
    return majority_mode or "N/A"
end

local function get_config()

    local sections = uci:get_all("ispapp", "config")
    return sections
end

-- Function to check if a command exists
local function commandExists(command)
    return sys.exec("opkg list-installed | grep " .. command) ~= "" and true or
               false
end

-- Function to extract a value by key from the release info
local function getReleaseValue(key)
    -- Read the content of /etc/openwrt_release
    local release_info = sys.exec("cat /etc/openwrt_release")
    local pattern = key .. "='(.-)'"
    return release_info:match(pattern)
end

local function getCPUInfo()
    -- Execute the command to get the content of /proc/cpuinfo
    local cpuinfo = sys.exec("cat /proc/cpuinfo")

    local core_count = 0
    local model_name = ""

    -- Iterate through each line of /proc/cpuinfo
    for line in cpuinfo:gmatch("[^\r\n]+") do
        -- Check for processor lines to count the cores
        if line:find("^processor%s*:%s*%d+") then
            core_count = core_count + 1
        end

        -- Check for model name
        if line:find("^model name%s*:%s*") then
            model_name = line:match("^model name%s*:%s*(.+)")
        end
    end

    -- Return the number of cores and the model name
    return core_count, model_name
end

local function getHardwareSerialNumber()
    local serial = sys.exec("cat /proc/cpuinfo | grep Serial")
    return serial:match("Serial%s*:%s*(%S+)") or "Unknown"
end

-- Single function to fetch interfaces, check for bridge memberships, and gather network stats
local function getNetworkInterfaces()
    local interfaces = {}

    -- Ensure the ubus connection is established
    if not conn then return nil, "Failed to connect to ubus" end

    -- Function to get bridge members for a specific bridge (e.g., br-lan)
    local function getBridgeMembers(bridge)
        local bridgeStatus = conn:call("network.device", "status",
                                       {name = bridge})
        return bridgeStatus['bridge-members'] or {}
    end

    -- Fetch all network devices using 'network.device' from ubus
    local devices = conn:call("network.device", "status", {})

    -- Track which interfaces belong to which bridges
    local bridgeMembers = {}

    -- Check for any bridges and fetch their members
    for iface, data in pairs(devices) do
        if data.type == "bridge" then
            local members = getBridgeMembers(iface)
            for _, member in ipairs(members) do
                bridgeMembers[member] = iface -- Map bridge members to the bridge (master interface)
            end
        end
    end

    -- Iterate over each device (interface)
    for iface, data in pairs(devices) do
        local mac = data.macaddr or "00:00:00:00:00:00" -- Default to all zeros if MAC is missing

        -- If no MAC address is present, skip this interface
        if mac ~= nil then
            -- Check if the interface is part of a bridge and assign the bridge as the default interface
            local defaultIf = bridgeMembers[iface] or iface

            -- Extract network statistics from the 'statistics' table in the ubus data
            local stats = data.statistics or {}

            -- Add the interface with its stats to the table
            table.insert(interfaces, {
                defaultIf = defaultIf, -- Set to bridge if part of a bridge, otherwise use iface
                ["if"] = iface,
                mac = mac, -- Keep MAC address even if it is '00:00:00:00:00:00'
                recBytes = stats.rx_bytes or 0,
                sentBytes = stats.tx_bytes or 0,
                recPackets = stats.rx_packets or 0,
                sentPackets = stats.tx_packets or 0,
                recErrors = stats.rx_errors or 0,
                sentErrors = stats.tx_errors or 0,
                recDrops = stats.rx_dropped or 0,
                sentDrops = stats.tx_dropped or 0,
                carrierChanges = stats.tx_carrier_errors or 0, -- Use tx_carrier_errors for carrier change stats
                foundDescriptor = "ubus parsed"
            })
        end
    end

    -- Return the list of interfaces
    return interfaces
end

-- Function to get external IP info and fill missing fields with "N/A"
local function getExternalIpInfo()
    -- Perform an HTTP GET request using luci.sys.httpget and fetch the JSON response as a string
    local jsonString = sys.httpget("http://ifconfig.co/json", false)

    -- Initialize a table with "N/A" as default values
    local info = {
        ip = "N/A",
        country = "N/A",
        city = "N/A",
        asn = "N/A",
        region_name = "N/A",
        region_code = "N/A",
        time_zone = "N/A",
        latitude = 0,
        longitude = 0,
        country_iso = "N/A"
    }

    -- Try to parse the JSON data if jsonString is not nil or empty
    if jsonString and jsonString ~= "" then
        local parsedData = jsonc.parse(jsonString)

        -- Check if JSON parsing is successful and then extract data
        if parsedData then
            info.ip = parsedData.ip or "N/A"
            info.country = parsedData.country or "N/A"
            info.city = parsedData.city or "N/A"
            info.asn = parsedData.asn or "N/A"
            info.region_name =
                parsedData.region_name and parsedData.region_name or "N/A"
            info.region_code =
                parsedData.region_code and parsedData.region_code or "N/A"
            info.time_zone = parsedData.time_zone and parsedData.time_zone or
                                 "N/A"
            info.latitude = parsedData.latitude and parsedData.latitude or "N/A"
            info.longitude = parsedData.longitude and parsedData.longitude or
                                 "N/A"
            info.country_iso =
                parsedData.country_iso and parsedData.country_iso or "N/A"
        end
    end

    -- Return the info table, ignoring any errors
    return info
end

-- Function to parse /etc/os-release and return information as a Lua table
local function parseOsRelease()
    local osReleasePath = "/etc/os-release"
    local osInfo = {
        NAME = "N/A",
        VERSION = "N/A",
        ID = "N/A",
        ID_LIKE = "N/A",
        PRETTY_NAME = "N/A",
        VERSION_ID = "N/A",
        HOME_URL = "N/A",
        BUG_URL = "N/A",
        SUPPORT_URL = "N/A",
        BUILD_ID = "N/A",
        OPENWRT_BOARD = "N/A",
        OPENWRT_ARCH = "N/A",
        OPENWRT_TAINTS = "N/A",
        OPENWRT_DEVICE_MANUFACTURER = "N/A",
        OPENWRT_DEVICE_MANUFACTURER_URL = "N/A",
        OPENWRT_DEVICE_PRODUCT = "N/A",
        OPENWRT_DEVICE_REVISION = "N/A",
        OPENWRT_RELEASE = "N/A"
    }

    -- Check if the file exists
    if fs.access(osReleasePath) then
        -- Read the file contents
        local fileContent = fs.readfile(osReleasePath)
        if fileContent and fileContent ~= "" then
            -- Split content into lines
            for line in fileContent:gmatch("[^\r\n]+") do
                -- Split each line into key and value
                local key, value = line:match("^(%S+)=\"?(.*)\"?$")
                if key and value then
                    osInfo[key] = value:gsub('\"$', "") -- Store the value in the osInfo table
                end
            end
        end
    end

    return osInfo
end

-- Function to collect security profiles of all wireless interfaces from UCI
local function collectSecurityProfiles()
    local profiles = {}

    -- Create a table to map device section to MAC address, hwmode, and htmode
    local device_info = {}

    -- Get all wireless device and interface sections
    -- uci:foreach("wireless", "wifi-device", function(section)
    --     device_info[section[".name"]] = {macaddr = section.macaddr or "N/A"}
    -- end)
    -- Get the hostname for the supplicant-identity
    -- local hostname = sys.hostname()
    uci:foreach("wireless", "wifi-iface", function(section)
        local profile = {
            [".id"] = "*" .. tostring(section['.index']), -- Use index as ID for the profile
            ["name"] = tostring(section['.name']),
            ["authentication-types"] = {section.encryption or "none"}, -- Directly use section.encryption
            -- name = section.ssid or "N/A", -- Use SSID or default
            -- ["supplicant-identity"] = hostname, -- Set supplicant-identity to the hostname
            technology = "wireless"
        }
        if section.sae_password then
            if type(section.key) == "string" then
                profile["wpa3-pre-shared-key"] = section.sae_password or ""
            else
                profile["wpa3-pre-shared-key"] = section.sae_password[0] or ""
            end
        end
        if section.key then
            if type(section.key) == "string" then
                profile["wpa-pre-shared-key"] = section.key or ""
                profile["wpa2-pre-shared-key"] = section.key or ""
            else
                profile["wpa-pre-shared-key"] = section.key[0] or ""
                profile["wpa2-pre-shared-key"] = section.key[0] or ""
            end
        end
        -- Get device information from the corresponding wifi-device section
        local device_name = section.device or "default" -- Get the device name associated with the iface
        -- local device_details = device_info[device_name] or
        --                            {
        --         macaddr = "N/A",
        --         hwmode = "N/A",
        --         htmode = "N/A"
        --     }
        -- -- Add MAC address, hwmode, and htmode to the profile
        -- profile["mac-addr"] = device_details.macaddr
        profile["mode"] = section.mode
        profile["default"] = false
        -- if section.mld and section.mld ~= "" then
        --     profile["default"] =  true
        -- end
        -- Add the profile to the profiles table
        table.insert(profiles, profile)
    end)

    return profiles
end

local function get_sequence_time()
    local config = "ispapp"
    local section = "config"

    -- Get current sequenceNumber and increment it
    local sequenceNumber = tonumber(
                               uci:get(config, section, "sequenceNumber") or "0")
    sequenceNumber = sequenceNumber + 1

    -- Get the current timestamp for lastConfigRequest (as a Unix timestamp)
    local lastConfigRequest = tonumber(sys.exec("date +%s"))

    -- Update UCI with new values
    uci:set(config, section, "sequenceNumber", tostring(sequenceNumber))
    uci:set(config, section, "lastConfigRequest", lastConfigRequest)

    -- Commit the changes to UCI
    uci:commit(config)

    -- Return the updated values
    return {
        lastConfigRequest = tonumber(lastConfigRequest),
        sequenceNumber = sequenceNumber
    }
end

local function is_using_websocket()
    local config = "ispapp"
    local section = "config"

    -- Retrieve the Domain value from the config
    local Domain = uci:get(config, section, "Domain")

    -- Check if Domain starts with ws:// or wss:// (for WebSocket and secure WebSocket)
    if Domain and (Domain:match("^ws://") or Domain:match("^wss://")) then
        return true
    else
        return false
    end
end

local function wirelessSupport()
    -- Try to find wireless interfaces using 'iw dev'
    local iw_output = sys.exec("iw dev")

    -- If 'iw dev' has output, then wireless interfaces exist
    if iw_output and iw_output ~= "" then return true end

    -- If 'iw dev' didn't return anything, try using 'ifconfig'
    local ifconfig_output = sys.exec("ifconfig -a")

    -- Look for typical wireless interface prefixes (e.g., wlan, wifi)
    local wireless_interfaces = {"wlan", "wifi", "ath", "ra"} -- Common wireless prefixes

    for _, prefix in ipairs(wireless_interfaces) do
        if ifconfig_output:match(prefix) then return true end
    end

    -- If no wireless interfaces found, return false
    return false
end

local function wirelessConfigured()
    local wireless_info = {}
    local band_map = {
        ["11-1997"] = "2.4ghz-dsss/fhss",
        ["11b"] = "2.4ghz-hr/dsss",
        ["11a"] = "5ghz-ofdm",
        ["11g"] = "2.4ghz-erp-ofdm",
        ["11n"] = "2.4/5ghz-ht-ofdm",
        ["11beg"] = "2.4ghz-ofdm",
        ["11ac"] = "5ghz-vht-ofdm",
        ["11ax"] = "2.4/5/6ghz-he-ofdma",
        ["11be"] = "2.4/5/6ghz-eht-ofdma",
        ["11ad"] = "60ghz-dmg",
        ["11ay"] = "60ghz-edmg",
        ["11ah"] = "sub-1ghz-s1g",
        ["11p"] = "5.9ghz-vehicular",
        ["11bd"] = "5.9/60ghz-vehicular",
        ["11ba"] = "2.4/5ghz-wur",
        ["11bn"] = "2.4/5/6/42/60/71ghz-uhr",
        ["11bea"] = "2.4/5/6ghz-eht-ofdma"
    }

    uci:foreach("wireless", "wifi-iface", function(section)
        local device = section.device
        local ssid = section.ssid or "N/A"
        local encryption = section.encryption or "none"
        local macaddr = uci:get("wireless", device, "macaddr") or "N/A"
        local disabled = section.disabled == "1"
        local running = sys.exec("iw dev " .. section.device ..
                                     " info 2>/dev/null"):match("Interface") ~=
                            nil
        local band = uci:get("wireless", device, "hwmode") or "N/A"
        local interface_type = uci:get("wireless", device, "type") or "N/A"

        -- Translate the band (hwmode) into readable format
        local band_readable = band_map[band] or "N/A"
        -- local band_readable = band_map[band] or "N/A"

        -- Build the object structure
        table.insert(wireless_info, {
            [".id"] = "*" .. tostring(section['.index']),
            band = band_readable,
            disabled = disabled,
            ["hide-ssid"] = section.hidden == "1",
            name = section['.name'] or "N/A",
            ["if"] = section['.name'] or "N/A",
            ["interface-type"] = interface_type,
            key = section.key or "N/A",
            ["mac-address"] = macaddr,
            ["master-interface"] = interface_type,
            running = running,
            ["security-profile"] = "*" .. tostring(section['.index']),
            ssid = ssid,
            technology = "uci"
        })
    end)

    return wireless_info
end
-- get uptime in seconds
local function get_uptime()
    local uptime_str = sys.exec("cat /proc/uptime")
    local uptime_seconds, idle_time_seconds = uptime_str:match("^(%S+) (%S+)")
    return math.floor(tonumber(uptime_seconds) or 0),
           math.floor(tonumber(idle_time_seconds) or 0)
end

-- Function to generate the CollectConfigs response
local function CollectConfigs()
    local seq_lasttmp = get_sequence_time()
    local cpucores, cpumodel = getCPUInfo()
    local ipinfo = getExternalIpInfo()
    local osrelease = parseOsRelease()
    local uptime, idle_time = get_uptime()
    local response = {
        bandwidthTestSupport = commandExists("iperf") or commandExists("iperf3") or
            commandExists("btest"),
        clientInfo = getReleaseValue("DISTRIB_ID") .. "-" ..
            getReleaseValue("DISTRIB_RELEASE"),
        firmwareUpgradeSupport = commandExists("fwupgrade-tools"),
        fw = getReleaseValue("DISTRIB_DESCRIPTION"),
        hardwareCpuInfo = cpumodel .. ", " .. cpucores .. " cores",
        hardwareMake = sys.exec("cat /tmp/sysinfo/board_name"):gsub("%s+$", ""),
        hardwareModel = sys.exec("cat /sys/firmware/devicetree/base/model"),
        hardwareModelNumber = sys.exec("cat /tmp/sysinfo/model"):gsub("%s+$", ""),
        hardwareSerialNumber = getHardwareSerialNumber(),
        hostname = sys.hostname(),
        interfaces = getNetworkInterfaces(),
        lastConfigRequest = seq_lasttmp.lastConfigRequest,
        os = osrelease.VERSION_ID,
        osBuildDate = fs.stat("/sys/class").mtime,
        osVersion = osrelease.VERSION,
        outsideIp = ipinfo.ip,
        Lng = tonumber(ipinfo.longitude),
        lat = tonumber(ipinfo.latitude),
        ["security-profiles"] = collectSecurityProfiles(),
        sequenceNumber = seq_lasttmp.sequenceNumber,
        uptime = uptime,
        usingWebSocket = is_using_websocket(),
        webshellSupport = true,
        wirelessConfigured = wirelessConfigured(),
        wirelessSupport = wirelessSupport()
    }

    return response
end
local function getPing()
    local ping_data = {host = "1.1.1.1"}
    local okcmd, pingcmd = pcall(util.exec, string.format([[
    ping -c 3 %s -q | tail -1 | awk -F' = ' '{split($2, arr, "/"); gsub(" ms", "", arr[1]); gsub(" ms", "", arr[2]); gsub(" ms", "", arr[3]); print "{\"min\": " arr[1] ", \"avg\": " arr[2] ", \"max\": " arr[3] "}"}'
    ]], ping_data.host))
    if not okcmd then
        return {
            host = ping_data.host,
            avgRtt = 0,
            minRtt = 0,
            maxRtt = 0,
            loss = 100
        }
    end
    local ok, ping = pcall(jsonc.parse, pingcmd)
    if not ok then
        return {
            host = ping_data.host,
            avgRtt = 0,
            minRtt = 0,
            maxRtt = 0,
            loss = 100
        }
    end
    ping_data = {
        host = ping_data.host,
        avgRtt = tonumber(ping.avg, 10),
        minRtt = tonumber(ping.min, 10),
        maxRtt = tonumber(ping.max, 10),
        loss = 0
    }
    return ping_data
end
-- Function to get interface statistics
local function get_interface_stats()
    local interfaces = {}
    -- ubus -v call iwinfo devices
    local devices = conn:call("network.device", "status", {})
    if devices then
        for name, iface_status in pairs(devices) do
            -- ubus -v call network.device status '{"name":"<name>"}'
            local stats = iface_status.statistics or {}
            local interf = {}
            interf["if"] = name
            interf["defaultIf"] = name
            interf["mac"] = iface_status.macaddr or "00:00:00:00:00:00"
            interf["recBytes"] = stats.rx_bytes or 0
            interf["recPackets"] = stats.rx_packets or 0
            interf["recErrors"] = stats.rx_errors or 0
            interf["recDrops"] = stats.rx_dropped or 0
            interf["up"] = iface_status.up or false
            interf["sentBytes"] = stats.tx_bytes or 0
            interf["sentPackets"] = stats.tx_packets or 0
            interf["sentErrors"] = stats.tx_errors or 0
            interf["sentDrops"] = stats.tx_dropped or 0
            interf["carrierChanges"] = stats.tx_carrier_errors or 0
            interf["type"] = iface_status.type or "N/A"
            interf["bridge-members"] = iface_status["bridge-members"] or {}
            interf["macs"] = 0
            interf["foundDescriptor"] = "ubus parsed"
            table.insert(interfaces, interf)
        end
    else
        log_error("Failed to get interface statistics")
    end

    return interfaces
end

local function AddCollectorsToConfig()
    local ping = getPing()
    -- local configs = CollectConfigs()
    -- type Collector struct {
    --     Interface         []Interface       `json:"interface"`
    --     Ping              []Ping            `json:"ping"`
    --     System            System            `json:"system"`
    --     Wap               []Wap             `json:"wap"`
    --     Tcp               TcpCollector      `json:"tcp"`
    --     Sensor            Sensor            `json:"sensor"`
    --     Gauge             []Gauge           `json:"gauge"`
    --     Counter           []Counter         `json:"counter"`
    --     MGauge            []MGauge          `json:"mgauge"`
    --     MCounter          []MCounter        `json:"mcounter"`
    --     LocationCollector LocationCollector `json:"location"`
    -- }
    local interface = get_interface_stats()
    -- type Wap struct {
    --     Interface       string    `json:"interface"`
    --     Ssid            string    `json:"ssid,omitempty"`
    --     Stations        []Station `json:"stations"`
    --     Signal0         float64   `json:"signal0"`
    --     Signal1         float64   `json:"signal1"`
    --     Signal2         float64   `json:"signal2"`
    --     Signal3         float64   `json:"signal3"`
    --     Noise           float64   `json:"noise"`
    --     FoundDescriptor string
    --     Key             string `json:"key"`
    --     Keytypes        string `json:"keytypes"`
    -- }
    -- type Station struct {
    --     Mac             string  `json:"mac"`
    --     Info            string  `json:"info"`
    --     Rssi            float64 `json:"rssi"`
    --     RecBytes        uint64  `json:"recBytes"`
    --     SentBytes       uint64  `json:"sentBytes"`
    --     Ccq             float64 `json:"ccq"`
    --     Noise           float64 `json:"noise"`
    --     Signal0         float64 `json:"signal0"`
    --     Signal1         float64 `json:"signal1"`
    --     Signal2         float64 `json:"signal2"`
    --     Signal3         float64 `json:"signal3"`
    --     ExpectedRate    uint64  `json:"expectedRate"`
    --     AssocTime       uint64  `json:"assocTime"`
    --     BeaconLoss      uint64  `json:"beaconLoss"`
    --     FoundDescriptor string
    -- }
    return {ping = ping, interface = interface}
end
-- Function to generate a unique identifier based on system properties
local function gather_unique_id()
    -- Function to get the MAC address using `ifconfig`
    local function get_mac_address()
        local mac_address = nil
        -- Run the `ifconfig` command and capture the output
        local ifconfig_output = sys.exec("/sbin/ifconfig -a")
        if not ifconfig_output then return "00:00:00:00:00:00" end
        -- Look for the MAC address in the output (adjust the pattern if needed)
        mac_address = ifconfig_output:match(
                          "HWaddr (%x%x:%x%x:%x%x:%x%x:%x%x:%x%x)")

        -- If no MAC address found, fall back to nil
        return mac_address or "00:00:00:00:00:00"
    end
    -- Gather necessary values
    local mac_address = get_mac_address() -- MAC address of the specified interface
    local cpucores = tonumber(sys.exec(
                                  "cat /proc/cpuinfo | grep 'processor' | wc -l")) or
                         0 -- Number of CPU cores

    -- Get RAM size
    local ram_size = 0
    local ram_partitions = tonumber(sys.exec(
                                        "cat /proc/partitions | grep ram | wc -l")) or
                               0
    if ram_partitions > 0 then
        ram_size = ram_partitions * 4096 -- Assuming each ram partition is 4096 blocks
    end

    -- Get MTD size and count
    local mtd_size = 0
    local mtd_partitions = tonumber(sys.exec(
                                        "cat /proc/partitions | grep mtdblock | wc -l")) or
                               0
    if mtd_partitions > 0 then
        local mtd_data = sys.exec("cat /proc/partitions | grep mtdblock")
        for line in mtd_data:gmatch("[^\r\n]+") do
            local _, _, blocks = line:find("(%d+)%s+(%d+)%s+(%d+)%s+mtdblock%d")
            if blocks then mtd_size = mtd_size + tonumber(blocks) end
        end
    end

    -- Gather CPU specifications (e.g., BogoMIPS)
    local bogomips = sys.exec(
                         "cat /proc/cpuinfo | grep 'BogoMIPS' | head -n 1 | awk '{print $3}'") or
                         "0"

    -- Number of ports can be gathered from network interfaces
    local num_ports = tonumber(sys.exec(
                                   "ls /sys/class/net/ | grep 'eth' | wc -l")) or
                          0

    -- Combine all values into a string
    local unique_string = string.format("%s%d%d%d%s%d", mac_address, cpucores,
                                        ram_size, mtd_size, bogomips, num_ports)
    -- local md5_module, err = pcall(require, "md5c")
    -- Function to generate UUID format from the unique string
    local hash = md5.tohex(unique_string:gsub("[%.:\n]", "")) -- or use any hashing library available
    local res = string.format("%s-%s-4%s-%s-%s", hash:sub(1, 8),
                              hash:sub(9, 12), hash:sub(13, 16),
                              hash:sub(17, 20), hash:sub(21))

    return res
end
local function check_domain()
    local host = uci:get("ispapp", "@settings[0]", "Domain")
    local port = uci:get("ispapp", "@settings[0]", "ListenerPort")
    if not host then return {status = 404} end
    local uri = string.format('https://' .. host .. ':' .. port)
    local responce = getRequest(uri, 1)
    return {status = responce.code}
end
local function GetTokens(uri)
    local res = getRequest(uri, 1)
    if res.code == 200 then
        local tokens = jsonc.parse(res.body)
        uci:set("ispapp", "@settings[0]", "refreshToken", tokens.refreshToken)
        uci:set("ispapp", "@settings[0]", "accessToken", tokens.accessToken)
        uci:commit('ispapp')
        return jsonc.parse(res.body)
    else
        return {status = res.code, body = res.body}
    end
end

local function host_signup()
    if not uci:get("ispapp", "@settings[0]") then return nil end
    local host = uci:get("ispapp", "@settings[0]", "Domain") or
                     "provisioning.ispapp.co"
    local port = uci:get("ispapp", "@settings[0]", "ListenerPort") or "443"
    local key = uci:get("ispapp", "@settings[0]", "Key") or ""
    local uuid_req = string.format("https://%s:%s/auth/uuid", host, port)
    local login = ""
    local uci_login = uci:get("ispapp", "@settings[0]", "login")
    local env_login = sys.exec(
                          "fw_printenv | grep login | awk -F '=' '{print $2}'")
    local function set_login(_login)
        uci:set("ispapp", "@settings[0]", "login", _login)
        uci:commit("ispapp")
    end
    if uci_login and uci_login ~= "00000000-0000-0000-0000-000000000000" then
        login = uci_login
    elseif env_login and env_login == "00000000-0000-0000-0000-000000000000" then
        login = env_login
        set_login(uci_login)
    else
        local res_uuid = getRequest(uuid_req, 1)
        login = res_uuid.body or gather_unique_id()
        local ok, _, _ = pcall(util.exec, "fw_setenv login " .. login)
        if ok then
            log_info(
                "\npersisting loin into the fw boot environment:" .. login ..
                    "\n")
        end
        set_login(login)
    end
    local init_req = string.format('https://%s:%s/initconfig?login=%s&key=%s',
                                   host, port, login, key)
    local _config = CollectConfigs()
    local res = postRequest(init_req, _config, 1)
    local tokens = {}
    if res.code == 200 then
        log_info("Host added successfully")
        tokens = GetTokens(init_req)
    else
        log_error("Failed to add host")
    end
    return {
        status = res.status,
        body = res.body,
        code = res.code,
        tokens = tokens
    }
end

local function get_cpu_usage()
    -- Get the PID of the ispappd process
    local path = "/var/run/ispappd.pid"
    local pid = read_file(path)
    if not pid.result then
        log_error(
            "Failed to read file " .. path .. "(ispappd is not running): " ..
                pid.error)
        return "(ispappd is not running)%"
    end

    local PID = pid.result:gsub("%D", "")
    local statm_file = string.format(
                           "pidstat -p %s | awk 'NR>3 {print $8}' | tr -d '\n'",
                           PID)
    local ok, statm_content, err = pcall(sys.exec, statm_file)
    if ok then
        return statm_content .. "%"
    else
        return "N/A%"
    end
end
local function check_service()
    local cmd = "/etc/init.d/ispapp status"
    local output = sys.exec(cmd)
    if output == nil then
        log_error("Failed to execute command: " .. cmd)
        return "N/A"
    end
    return output
end

local function SignUp()
    local sd = host_signup()
    return {result = jsonc.stringify(sd)}
end

local methods = {
    test = {
        call = function()
            local r = {}
            r.result = jsonc.stringify(AddCollectorsToConfig())
            return r
        end
    },
    signup = {call = SignUp},
    collect_configs = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({configs = CollectConfigs()})
            return r
        end
    },
    get_cpu_usage = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({cpu_usage = get_cpu_usage()})
            return r
        end
    },
    read_ispapp_config = {call = function() return get_config() end},
    write_ispapp_config = {
        args = {config = "table"},
        call = function(args) return set_config(args.config) end
    },
    check_ispapp_status = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({status = check_service()})
            return r
        end
    },
    stop_ispapp = {call = function() return manage_service("stop") end},
    restart_ispapp = {call = function() return manage_service("restart") end},
    start_ispapp = {call = function() return manage_service("restart") end},
    suspend_ispapp = {call = function() return manage_service("stop") end},
    query_ispapp = {call = query_service},
    read_pid_file = {
        call = function() return read_file("/var/run/ispapp.pid") end
    },
    check_domain = {
        call = function()
            local r = {}
            r.result = jsonc.stringify(check_domain())
            return r
        end
    },
    read_runtime_file = {
        call = function() return read_file("/tmp/ispapp_runtime.json") end
    },
    verify_config = {
        call = function() return jsonc.stringify(verify_config()) end
    },
    read_crontab = {
        call = function() return read_file("/etc/crontabs/root") end
    },
    get_last_edit_time = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({last_edit_time = get_last_edit_time()})
            return r
        end
    },
    get_active_time = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({active_time = get_active_time()})
            return r
        end
    },
    get_process_info = {
        args = {pid = "a_number"},
        call = function(args)
            local r = {}
            r.result = jsonc.stringify({cpu_usage = get_process_info(args.pid)})
            return r
        end
    },
    get_device_mode = {
        call = function()
            local r = {}
            r.result = jsonc.stringify({device_mode = get_device_mode()})
            return r
        end
    }
}

local function parseInput()
    local function read_with_timeout(timeout)
        local start_time = os.time()
        local input = ""
        while os.time() - start_time < timeout do
            local chunk = arg[3]
            if not chunk then break end
            input = input .. chunk
        end
        return input
    end

    local input = read_with_timeout(.01)
    local args = jsonc.parse(input)
    if not args then return {} end
    return args
end

local function validateArgs(func, uargs)
    -- Validates that arguments picked out by parseInput actually match
    -- up to the arguments expected by the function being called.
    local method = methods[func]
    if not method then
        print(jsonc.stringify({error = "Method not found in methods table"}))
        os.exit(1)
    end

    -- Lua has no length operator for tables, so iterate to get the count
    -- of the keys.
    local n = 0
    for _, _ in pairs(uargs) do n = n + 1 end

    -- If the method defines an args table (so empty tables are not allowed),
    -- and there were no args, then give a useful error message about that.
    if method.args and n == 0 then
        print(jsonc.stringify({
            error = "Received empty arguments for " .. func ..
                " but it requires " .. jsonc.stringify(method.args)
        }))
        os.exit(1)
    end

    uargs.ubus_rpc_session = nil

    local margs = method.args or {}
    for k, v in pairs(uargs) do
        if margs[k] == nil or (v ~= nil and type(v) ~= type(margs[k])) then
            print(jsonc.stringify({
                error = "Invalid argument '" .. k .. "' for " .. func ..
                    " it requires " .. jsonc.stringify(method.args)
            }))
            os.exit(1)
        end
    end

    return method
end

if arg[1] == "list" then
    local _, rv = nil, {}
    for _, method in pairs(methods) do rv[_] = method.args or {} end
    print((jsonc.stringify(rv):gsub(":%[%]", ":{}")))
elseif arg[1] == "call" then
    local args = parseInput()
    local method = validateArgs(arg[2], args)
    local run = method.call(args)
    print(run.result)
    os.exit(run.code or 0)
elseif arg[1] == "help" then
    local helptext = [[
Usage:

 To see what methods are exported by this script:
    ubus call ispapp list

 To call this script via ubus:
    ubus call ispapp method_name '{"valid": "json", "argument": "value"}'
]]
    print(helptext)
end
